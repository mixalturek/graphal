%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

%% History:
% Pavel Tvrdik (26.12.2004)
%  + initial version for PhD Report
%
% Daniel Sykora (27.01.2005)
%
% Michal Valenta (3.12.2008)
% rada zmen ve formatovani (diky M. Duškovi, J. Holubovi a J. Žďárkovi)
% sjednoceni zdrojoveho kodu pro anglickou, ceskou, bakalarskou a diplomovou praci


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\documentclass[11pt,twoside,a4paper]{book}
\usepackage[czech, english]{babel}

%\usepackage[T1]{fontenc} % pouzije EC fonty
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
%\usepackage{indentfirst} %1. odstavec jako v cestine.

\usepackage{k336_thesis_macros}


\newcommand\TypeOfWork{Diplomová práce} % \typeout{Diplomova prace}
%\newcommand\TypeOfWork{Master's Thesis}   \typeout{Master's Thesis}


% http://www.fel.cvut.cz/cz/education/bk/prehled.html

\newcommand\StudProgram{Elektrotechnika a informatika, strukturovaný, Navazující magisterský}
%\newcommand\StudProgram{Electrical Engineering and Information Technology}  % master program

\newcommand\StudBranch{Výpočetní technika}   % pro prgoram EaI mag. (dobihajici i strukt.)
%\newcommand\StudBranch{Computer Science and Engineering}  % master programe


\newcommand\WorkTitle{Interpret grafových algoritmů}
\newcommand\FirstandFamilyName{Bc. Michal Turek}
\newcommand\Supervisor{RNDr. Marko Genyk-Berezovskyj}



% \hyphenation{  }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\usepackage[
pdftitle={\WorkTitle},
pdfauthor={\FirstandFamilyName},
bookmarks=true,
colorlinks=true,
breaklinks=true,
urlcolor=red,
citecolor=blue,
linkcolor=blue,
unicode=true,
]
{hyperref}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\begin{document}

\selectlanguage{czech}
%\selectlanguage{english}

\iflanguage{czech}{
%	 \typeout{************************************************}
%	 \typeout{Zvoleny jazyk: cestina}
%	 \typeout{Typ prace: \TypeOfWork}
%	 \typeout{Studijni program: \StudProgram}
%	 \typeout{Obor: \StudBranch}
%	 \typeout{Jmeno: \FirstandFamilyName}
%	 \typeout{Nazev prace: \WorkTitle}
%	 \typeout{Vedouci prace: \Supervisor}
%	 \typeout{***************************************************}
	 \newcommand\Department{Katedra počítačů}
	 \newcommand\Faculty{Fakulta elektrotechnická}
	 \newcommand\University{České vysoké učení technické v Praze}
	 \newcommand\labelSupervisor{Vedoucí práce}
	 \newcommand\labelStudProgram{Studijní program}
	 \newcommand\labelStudBranch{Obor}
}{
%	 \typeout{************************************************}
%	 \typeout{Language: english}
%	 \typeout{Type of Work: \TypeOfWork}
%	 \typeout{Study Program: \StudProgram}
%	 \typeout{Study Branch: \StudBranch}
%	 \typeout{Author: \FirstandFamilyName}
%	 \typeout{Title: \WorkTitle}
%	 \typeout{Supervisor: \Supervisor}
%	 \typeout{***************************************************}
	 \newcommand\Department{Department of Computer Science and Engineering}
	 \newcommand\Faculty{Faculty of Electrical Engineering}
	 \newcommand\University{Czech Technical University in Prague}
	 \newcommand\labelSupervisor{Supervisor}
	 \newcommand\labelStudProgram{Study Programme}
	 \newcommand\labelStudBranch{Field of Study}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\coverpagestarts


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\acknowledgements
\noindent

\noindent Rád bych poděkoval svému vedoucímu RNDr. Marku Genyk-Berezovskému za jeho připomínky a cené rady při tvoření práce. Druhou osobou zůstává Renat Rafisovič Kagirov, který se mě během studia na SibGAU v Krasnojarsku snažil přivést, bohužel neúspěšně, k psaní v angličtině. V této době vznikla podrobná osnova a úvodní kapitoly.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

% TODO: update information
\declaration{V Krasnojarsku dne 12.\,6.\,2009}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\abstractpage
The core of this diploma thesis is design and implementation of a special language based on C, which will be used for the graph manipulations. Integrated development environment was developed, it consists of the text editor for programmers, debugger and visualization window, in which the progress of the interpreted algorithm and graph can be displayed using 3D graphics.

\vglue60mm

\noindent{\Huge \textbf{Abstrakt}}
\vspace{8ex}

\noindent
Jádrem diplomové práce je návrh a implementace speciálního programovacího jazyka založeného na syntaxi C, který slouží pro manipulaci s grafy. Dále bylo vytvořeno integrované vývojové prostředí sestávající z programátorsky zaměřeného textového editoru, debuggeru a vizualizačního okna, v němž je ve 3D zobrazován průběh interpretovaného algoritmu nad daným grafem.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\tableofcontents
\listoffigures
\listoftables


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\mainbodystarts

\parskip=5pt plus 4pt minus 4pt
\parindent=0em


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Úvod}

Algoritmy \textit{difuze} slouží pro zpracování obrazů. Každý ví, že fungují, ale nikdo neví, jakým způsobem \textit{přesně} fungují. Výstupem tohoto projektu bude integrované vývojové prostředí pro psaní, ladění a vizualizaci průběhu takovýchto algoritmů.

Vstupními daty je obrázek a výstupem například, ve které jeho části se nachází objekt, kde je pozadí a podobně. Obrázek je převeden na speciální graf s několika vrcholy pro každý pixel a pospojovanými ohodnocenými hranami. Difuzní algoritmus pracuje s lokálními částmi grafu, iterativně aktualizuje ohodnocení hran a končí poté, co je splněna globální podmínka. Zadání může být tedy zobecněno z práce s obrázky na jednoduché grafové operace.

Cílem diplomové práce je návrh a implementace jazyka založeného na syntaxi C, který slouží pro manipulaci s grafy. Jazyk má podporu pro základní datové typy, jako jsou celá a desetinná čísla, řetězce, pole a struktury. Proměnné mohou být lokální i globální, bez deklarací. Výčet kontrolních struktur sestává z \texttt{if-else} podmínek, \texttt{for}, \texttt{while} a \texttt{foreach} cyklů, deklarace funkcí a jejich volání. \texttt{Include} a \texttt{define} direktivy preprocesoru jsou implementované na úrovni lexikálního analyzátoru. Jazyk nepodporuje ukazatele ani objektově orientované programování.

Speciální datové typy zahrnují grafy, vrcholy, hrany, množiny vrcholů a množiny hran. Interpret obsahuje zabudované funkce pro vytváření a rušení těchto proměnných, vracení sousedů daného vrcholu a další. Každému vrcholu a hraně může být přiřazen libovolný počet dalších hodnot, k přístupu k nim složí jméno předávané tečkovou notací \texttt{objekt.vlastnost}. Speciální řídící stuktury pro zpracování komplexních proměnných jsou implementovány na bázi iterátorů, jež jsou interně volané i ve \texttt{foreach} cyklu.

Grafické uživatelské rozhraní sestává především z programátorsky zaměřeného textového editoru se zvýrazňováním syntaxe, číslováním řádků, zvýrazněním aktuálního řádku, automatickým odsazováním a inteligentní klávesou \texttt{Home}. Všechny ostatní části aplikace jsou tvořeny panely, které mohou být uživatelem přesunuty na jiné místo, skryty a také \textit{vytrhnuty} z hlavního do samostatného okna, což je výhodné především v případě dvou monitorů. Mimo jiné je v nich možné zobrazit textový výstup z parsování a interpretace skriptu, zásobník volání funkcí, seznam definovaných proměnných a vizualizační okno.

Vizualizace jsou přímo propojené s krokováním skriptu či, přesněji řečeno, s debuggingem. Vykonávání může být pozastaveno breakpointem a poté krokováno s možností vstupu do funkcí, opuštění dané funkce či její vykonání a opětovné pozastavení. Při každém zastavení skriptu se aktualizuje panel zásobníku volání funkcí, seznam definovaných proměnných a vizualazace grafu, s níž se dá následně otáčet, přibližovat, oddalovat a provádět další 3D operace. Graf může být nahrán jak kódem skriptu, tak uživatelem ve vizualizačním okně.

Základní kód interpretu a rozhraní pro příkazovou řádku je napsáno v jazyce C++ s využitím parser generátoru Bison (LALR gramatika) a nezávisí na žádné externí knihovně kromě standardního STL. Tato část je tudíž zkompilovatelná na libovolné platformě, pro kterou existuje C++ kompilátor. Grafická část aplikace používá knihovnu Qt a vizualizace OpenGL, obě jsou dostupné na všech majoritních operačních systémech.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Popis problému, specifikace cíle}

% TODO: delete
%\begin{itemize}
%\item Popis řešeného problému, vymezení cílů DP/BP a požadavků na implementovaný systém.
%\item Popis struktury DP/BP ve vztahu k vytyčeným cílům.
%\item Rešeršní zpracování existujících implementací, pokud jsou známy.
%\end{itemize}


\section{Požadavky na aplikaci}

Navrhněte a implementujte interpret jazyka, který bude zaměřen na manipulaci s grafy. Jazyk bude obsahovat základní datové struktury nezbytné pro manipulaci s grafy a bude tak podporovat efektivní zápis grafových algoritmů. Interpret vybavte uživatelským rozhraním skládajícím se z editoru pro zápis algoritmu a dále grafickým oknem zobrazujícím interaktivně průběh algoritmu na konkrétním grafu. V grafické části aplikace využijte knihoven OpenGL.

Zásadní jsou neorientované grafy, implementace orientovaných je volitelná.

\subsection{Navrhovaný jazyk}

Jazykové konstrukce by měly být podobné jazyku C. Zahrnují základní datové typy, datové a řídící struktury.

\begin{itemize}
\item celá a desetinná čísla
\item pole
\item podmínky, cykly, deklarace a volání funkcí
\item výstup textu na vlastní konzolu
\item direktiva \texttt{include} v jednoduché verzi, tj. nikoli hlavičky, ale celé soubory

\item zvažte
	\begin{itemize}
	\item datový typ boolean
	\item znaky a řetězce, v jednoduché formě bez složitých funkcí pro manipulaci
	\item ukazatele a struktury jako v jazyce C
	\item objektově orientované vlastnosti
	\item čtení a zápis souborů, jde především o načítání specifikací grafu z externích souborů
	\end{itemize}

\item specifické elementy jazyka
	\begin{itemize}
	\item primitivní typy
		\begin{itemize}
		\item graf, vrchol, hrana, množina vrcholů, množina hran
		\end{itemize}
	\item základní funkce
		\begin{itemize}
		\item vytvoř/smaž graf/hranu/vrchol
		\item ohodnoť hranu/vrchol
		\item vrať všechny sousedy daného vrcholu
		\item vytvoř/zruš množinu vrcholů/hran, přidej/odeber vrchol/hranu
		\item vrať stupeň vrcholu
		\end{itemize}
	\item řídící struktury
		\begin{itemize}
		\item pro všechny sousedy daného vrcholu vykonej \texttt{příkaz}
		\item pro všechny vrcholy/hrany v dané množině vykonej \texttt{příkaz}
		\item pro všechny vrcholy/hrany grafu vykonej \texttt{příkaz}
		\end{itemize}
	\end{itemize}
\end{itemize}


\subsection{Textový editor}

Textový editor by měl být programátorsky zaměřený, zvýrazňování syntaxe je vítáno. Další vymoženosti podle dohody a možností.


\subsection{Zobrazovací jednotka, vizualizace}

Vizualizační jednotka zobrazuje aktuálně zpracovávaný graf ve 3D, nemusí to být editor, ve kterém je možné grafy editovat. Uživatel má interaktivní možnost graf natáčet, přibližovat, oddalovat a posouvat v libovolném směru. Dále vůže zapnout a vypnout zobrazování jednotlivých částí grafu, aby bylo možné dosáhnout méně přeplněného výstupu.

Pokud bude v jazyce možnost přidávat barevné (texturové?) atributy vrcholům, hranám nebo jejich množinám, promítaly by se i do zobrazení. Zobrazovací okno má vlastní možnost načtení grafu, aplikace umožní volit, zda má algoritmus pracovat s grafem, který je v grafickém okně nebo zda si jej načte sám podle zápisu v kódu.


\subsection{Manipulace s grafem, debugger}

Interpretace kódu může být krokována, po provedení jednoho příkazu se ve vizualizačním okně zobrazí aktuální stav zpracování grafu. V něm je možné následně měnit pohled na graf, dokud není vydán příkaz k dalšímu kroku. Parametry samotného grafu během průběhu programu není vhodné měnit, parametry zobrazení nejspíše ano (barvy, měřítka a podobně). Debugging není třeba nijak zvlášť podporovat, postačí konzole, kam si programátor může vypsat ladící a trasovací tisky.


\subsection{Systémové požadavky}

\begin{itemize}
	\item Verze pro příkazovou řádku
		\begin{itemize}
		\item platformy \texttt{i386} a \texttt{amd64}, podpora dalších volitelná
		\item operační systémy \texttt{GNU/Linux}, \texttt{MS Windows} (založený na NT) a \texttt{MacOS}, podpora dalších volitelná
		\item procesor min. 1 GHz
		\item operační paměť min. 2 GB RAM, v grafech se předpokládají miliony vrcholů
		\end{itemize}

	\item Grafická verze
		\begin{itemize}
		\item grafická karta s podporou OpenGL (např. \texttt{nVidia GeForce 2} a novější)
		\item nainstalované OpenGL ovladače a Qt4 knihovny
		\item rozlišení monitoru min. 1024x768
		\end{itemize}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Analýza a návrh řešení}

% TODO: delete
% Analýza a návrh implementace (včetně diskuse různých alternativ a volby im\-ple\-men\-tač\-ní\-ho prostředí).

\section{Obecný postup řešení}

Základním cílem tohoto projektu je vyvinout integrované vývojové prostředí pro programovací jazyk orientovaný na manipulace s grafy. Tato komplexní úloha může být rozdělena na několik více méně oddělených částí, které budou řešeny v následujícím pořadí.

\begin{enumerate}
\item Návrh jazyka pro manipulace s grafy, který odpovídá všem požadavkům
\item Návrh reprezentace grafů v aplikaci, jak k nim bude přistupováno z interpretu
\item Implementace lexikálního analyzátoru a parseru
\item Implementace interpretu pro příkazovou řádku
\item Návrh a implementace grafického vývojového prostředí a vizualizací
\end{enumerate}


\section{Volba jazyka a knihoven pro implementaci}

Na samém začátku je možné uvažovat tři běžně používané jazyky pro tvorbu sys\-té\-mo\-vých aplikací: C++, Javu a C\#. Třetí z nich může být automaticky vyškrtnut, protože neodpovídá zásadnímu požadavku na přenositelnost a především odporu autora práce. Jazyk C++ je portovatelný na úrovni zdrojových kódů a Java na úrovni byte kódu. Žádné skriptovací jazyky, jako například Perl a Python, nejsou uvažovány. Ačkoli mnoho vývojářů může tvrdit přesný opak, nejsou příliš vhodné pro tak velkou aplikaci a psát interpret v interpretovaném jazyce nevypadá hezky.

Obrovskými výhodami Javy je její automatický správce paměti a spousta existujících knihoven a frameworků. Na druhou stranu naprostá většina kompilátorů a interpretů je psaná v C nebo C++ kvůli kompilaci do strojového kódu a z ní vyplývající rychlosti provádění.

Autor při vývoji systémových aplikací preferuje C++ a má s ním také mnohem více zkušeností, a proto byl tento jazyk, spolu s knihovnou STL, zvolen pro implementaci aplikace. Žádná další knihovna nebude při tvorbě základního kódu použita, interpret pro příkazovou řádku by měl mít co nejméně externích závislostí. Díky tomu by měl být bez větších problémů portovatelný na všechny platformy, pro které existuje C++ kompilátor.

Grafické část aplikace bude naprogramována s použitím knihovny Qt. Je jednou z nejlépe navržených knihoven pro tvorbu GUI aplikací, přenositelná na všechny majoritní operační systémy a bezplatná pro nekomerční použití (licence GNU LGPL). Vizualizace grafů budou používat OpenGL, což je standard pro 3D grafiku. Druhá možná volba, Direct3D, není použitelná na ne-Microsoft platformách, a proto je zbytečné o ní byť i uvažovat.


\section{Embedded Python}

TODO: až bude internet ;-)

\begin{verbatim}
Python
	naprogramovat grafové třídy v Pythonu a zkusit použít
	http://www.python.org/doc/ext/embedding.html
	http://docs.python.org/lib/module-pdb.html
	jednoduché na implementaci, ale vlastní interpret jednodušší na použití
\end{verbatim}


\section{Návrh a specifikace vytvářeného jazyka}

Jak už bylo zmíněno, syntaxe jazyka je z větší části založena na všeobecně známém C, což programátorům přináší výhodu rychlého učení. Jazyk rozlišuje malá a velká písmena, je procedurální a nepodporuje objektově orientované vlastnosti.


\subsection{Datové typy a proměnné}
\label{datove_typy_a_promenne}

Proměnné se nedeklarují a v průběhu vykonávání skriptu mohou libovolně měnit svůj datový typ. Uvnitř interpretu jsou rozlišovány typy \texttt{null}, \texttt{bool}, \texttt{int}, \texttt{float}, \texttt{string}, \texttt{struct}, \texttt{array}, \texttt{graph}, \texttt{vertex}, \texttt{vertexset}, \texttt{edge} a \texttt{edgeset}. Jazyk nepodporuje modifikátory typu, jako jsou například \texttt{unsigned} nebo \texttt{const}, protože nepřinášejí žádné výrazné vylepšení, programátor se bude muset obejít bez nich.

Viditelnost proměnných je definována na úroveň funkcí, tudíž opuštění daného bloku (například cyklu) nezpůsobuje zrušení v něm používaných proměnných. Globální pro\-měn\-nou je možné ve funkci zpřístupnit po vzoru jazyka PHP klíčovým slovem \texttt{global}.

\begin{verbatim}
function example()
{
    global g_var;
    g_var = "some value";
}
\end{verbatim}

Při úvahách o deklaracích proměnných byly zvažovány celkem čtyři možnosti.

\begin{enumerate}
\item Jako v C, povinná
\item Jako v C, nepovinná
\item Jako v JavaScriptu pomocí \texttt{var jméno;}, nepovinná
\item Bez deklarací
\end{enumerate}

Na první pohled je jasné, že prostřední dvě možnosti nepřinášejí nic užitečného. Pokud jsou deklarace volitelné, nejde těžit z jejich výhod a pouze přidávají nová klíčová slova, což je patrné především u JavaScriptového způsobu.

Výhodou deklarací je snadná automatická detekce chyb a případně možnost větších optimalizací. Na druhou stranu příliš svazují, což je patrné především u skriptovacích jazyků, které se snaží o co nejmenší množství kódu na co největší funkcionalitu. Právě z tohoto důvodu byla zvolena verze bez deklarací.

Poznámka na okraj. Deklarace by se mohly hodit i pro automatizovaný překlad do jiných běžně používaných jazyků, než ve kterém byl napsán vlastní algoritmus. V tomto případě by se pravděpodobně jednalo o kompilovatelné C++ nebo Javu. Tato myšlenka je inspirována Google Web Toolkitem, který překládá javovské programy do HTML, CSS a JavaSkriptu, nejedná se o nic nereálného.


\subsection{Operátory}

Jazyk podporuje prakticky všechny operátory z jazyka C, s výjimkou operátoru čárky a bitových operátorů. Priority jsou stejné jako v C.

\begin{itemize}
\item Unární operátory
	\begin{itemize}
	\item \texttt{-}, \texttt{!}, \texttt{++}, \texttt{--}
	\end{itemize}
\item Binární operátory
	\begin{itemize}
	\item Aritmetické: \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{\%}
	\item Přiřazovací: \texttt{=}, \texttt{+=}, \texttt{-=}, \texttt{*=}, \texttt{/=}, \texttt{\%=}
	\item Přiřazení reference: \texttt{\&=}
	\item Logické: \texttt{==}, \texttt{!=}, \texttt{<=}, \texttt{>=}, \texttt{<}, \texttt{>} \texttt{\&\&}, \texttt{||}
	\item Přístup k prvkům: \texttt{.}, \texttt{[]}
	\end{itemize}
\item Ternární operátor
	\begin{itemize}
	\item \texttt{? :}
	\end{itemize}
\end{itemize}


\subsection{Řídící struktury}

Zápis podmínek a cyklů je naprosto stejný jako v C, je možné použít \texttt{if}, \texttt{if-else}, \texttt{for} a \texttt{while}. Vícenásobné větvení \texttt{switch} není implementováno, protože je bez problémů nahraditelné vnořenými \texttt{if-else} podmínkami.

Jazyk dále přináší cyklus \texttt{foreach}, který umí iterovat přes všechny prvky složeného datového typu, jímž jsou například pole a struktury, ale také vlastnosti vrcholů a hran. Cyklus \texttt{foreach} interně používá iterátory, které jsou v interpretu zpřístupněny přes zabudované funkce.

\begin{verbatim}
foreach(item; iterableObject)
{
    echo(item);
}
\end{verbatim}

Předčasné ukončení cyklu je možné klasicky pomocí strukturovaných skoků \texttt{break} a \texttt{continue}.


\subsection{Funkce}

Funkce se ve skriptu deklarují podobně jako v jazyce PHP. Klíčové slovo \texttt{function}, následuje jméno funkce, v kulatých závorkách čárkami oddělený seznam parametrů a ve složených závorkách tělo funkce. Při parsování nezávisí na pořadí deklarace funkcí, interpretace začíná až po zpracování celého zdrojového kódu, kdy už jsou všechny dostupné.

U volání funkcí jsou k dispozici dvě ekvivalentní syntaxe. V první verzi je možné všechny parametry předat klasicky do kulatých závorek, u druhého způsobu je první parametr zapsán tečkovou notací před jméno funkce a celý zápis potom vypadá, jako volání metody nad daným objektem. Forma je podobná jazyku Python a jeho \texttt{self} parametrům metod.

\begin{verbatim}
function someFunc(parameter1, parameter2, parameter3)
{
    return "some value";
}

someFunc(object, parameter2, parameter3);
object.someFunc(parameter2, parameter3);
\end{verbatim}

Při návrhu bylo zvažováno také předávání parametrů odkazem, tato technika se používá především k vracení několika hodnot z funkce najednou. Nakonec se ale došlo k závěru, že není vyloženě nutná, protože je možné uložit tyto hodnoty do struktury nebo pole a vrátit celý kontejner. Jednoduchost jazyka a nedeklarativnost proměnných k tomu přímo vybízí.


\subsection{Preprocesor}

Pro vložení zdrojového souboru, například knihovny funkcí, slouží příkaz \texttt{include} s cestou a jménem souboru v parametru. Nové makro je možné specifikovat příkazem \texttt{define}. Kdykoli se ve zdrojovém souboru najde specifikovaný identifikátor, je automaticky nahrazen hodnotou makra. Obě konstrukce se zpracovávají na úrovni lexikálního analyzátoru v době překladu.

\begin{verbatim}
include("filename");
define("name", "value");
\end{verbatim}


\subsection{Datové kontejnery}

Základními datovými kontejnery jsou pole a struktury, které se dají jednoduše rozšířit. Zásobník a fronta se z pole vytvoří definováním operací \texttt{pushFront()}, \texttt{push\-Back()}, \texttt{popFront()}, \texttt{popBack()}, \texttt{front()} a \texttt{back()}. Struktura se dá bez jakýchkoli změn po\-u\-ží\-vat i jako mapa (asociativní pole) a množina.

Na rozdíl od jiných skriptovacích jazyků není definována speciální syntaxe pro deklarace a vytváření. Pro zachování jednoduchosti stačí pouze zavolat zabudované funkce \texttt{array()} a \texttt{struct()}, které vrací nově vytvořený objekt daného datového typu, a ná\-sled\-ně je začít používat.

\begin{verbatim}
arr = array(5);
arr[0] = "item";
arr[1] = array(10);
arr[3] = 3.14;

st = struct();
st.name = "item";
st.valid = true;
\end{verbatim}


\subsection{Grafy, vrcholy a hrany}

První operací při práci s grafovými vlastnostmi jazyka je vždy \texttt{graph()}, zabudovaná funkce pro konstrukci objektu grafu. Je-li vytvořen graf, může se přistoupit k vytváření vrcholů a hran a následně k práci s nimi. Vrcholy a hrany se zároveň chovají i jako struktury, tudíž je u nich možné používat libovolný počet libovolně pojmenovaných vlastností.

\begin{verbatim}
g = graph();

v1 = g.generateVertex();
v2 = g.generateVertex();
e1 = g.generateEdge(v1, v2);

v1.color = "red";
v2.visited = false;
e1.value = 3.14;
neighbors = v1.getNeighbors();

foreach(vert; neighbors)
	doSomething(vert);
\end{verbatim}

Pro vytváření množin vrcholů a hran slouží opět zabudované funkce.


\subsection{Ukázka spustitelného skriptu}

Příkladem kompletního skriptu zapsaného ve vytvářeném jazyce bude rekurzivní prohledávání grafu do hloubky. Parametrem uživatelsky definované funkce \texttt{dfs()} je libovolný vrchol grafu. Pokud už byl daný vrchol navštíven, větev procházeného stromu se ukončí, v opačném případě se označí vrchol za navštívený a funkce se rekurzivně zavolá nad všemi jeho sousedy.

\begin{verbatim}
define("NEW", "0");
define("CLOSED", "1");

// Recursive depth first search
function dfs(v)
{
    if(v.state == CLOSED)
        return;

    echo("Closing vertex: " + v.num + "\n");
    v.state = CLOSED;

    foreach(neighbor; v.getNeighbors())
        dfs(neighbor);
}
\end{verbatim}


Výše definovaný algoritmus funguje nad všemi orientovanými i neorientovanými spojitými grafy. Od začátku vývoje se předpokládá nahrávání grafů z externích souborů, nicméně jejich vytváření je možné i v kódu programu.

V následujícím výpisu je definován netriviální neorientovaný graf o dynamicky definované velikosti. Každému vrcholu je nastavením vlastnosti \texttt{num} předáno pořadové číslo vytvoření. Následně je stav všech vrcholů inicializován na \texttt{NEW} a spuštěn algoritmus pro procházení do hloubky.

\begin{verbatim}
define("NUM_VERTICES", "10"); // In one layer

function main(argv)
{
    // o --- o --- o --- ...
    // |     |     |
    // o     o     o

    g = graph();
    v1 = g.generateVertex();
    v1.num = 0;
    first = v1;

    // Generate first layer
    for(i = 1; i < NUM_VERTICES; i++)
    {
        v2 = g.generateVertex();
        v2.num = i;

        g.generateEdge(v1, v2);
        v1 = v2;
    }

    // Generate second layer
    foreach(v1; g.getVertices())
    {
        v2 = g.generateVertex();
        v2.num = i++;
        g.generateEdge(v1, v2);
    }

    // Initialize states
    foreach(v; g.getVertices())
        v.state = NEW;

    // Run (any vertex first)
    dfs(first);
}
\end{verbatim}


\section{Analýza reprezentace grafu}

\subsection{Obecné požadavky}

Jedním ze základních kamenů vytvářené aplikace je reprezentace grafů, vrcholů, hran a jejich množin v kódu programu. Přímo ze zadání práce vyplývá několik skutečností, ostatní se dají odvodit, či odhalit prostou logikou. Následuje stručný přehled, který bude dále rozebírán a diskutován.

\begin{itemize}
\item typ podporovaných grafů
\item zapnutí a vypnutí orientace, inverze orientace
\item dynamické grafy, složitost vytváření nových uzlů a hran
\item způsob uložení vlastností uzlů a hran
\item zpětná reference na objekt celého grafu
\item identifikovatelnost sebe sama v grafu
\item přístup k sousedním uzlům
\item přístup k počátečnímu a koncovému uzlu hrany
\item reprezentace množin uzlů a hran, množinové operace
\item iterace přes všechny uzly/hrany grafu/množiny
\item paměťový management, paměťové nároky
\end{itemize}

První a nejdůležitější z otázek se ptá, jakou třídu grafů je třeba podporovat. Jelikož je program psán úplně od začátku a neexistují žádná omezení plynoucí z již existujícího kódu a napojování se na něj, je rozumnou volbou uvažovat maximální množinu všech grafů. Ta zahrnuje orientované i neorientované grafy, spojité i nespojité, několik paralelních hran mezi dvěma uzly a samozřejmě také smyčky nad uzlem -- tj. hrana začíná i končí ve stejném vrcholu. Dále v textu bude vidět, že toto rozhodnotí silně omezí možné způsoby implementace, popř. je výrazně zesložití.

Ačkoli se předpokládají spíše statické grafy, které se na začátku vytvoří a dále se už měnit nebudou, přidávání a mazání nových uzlů a hran by mělo být \textit{rozumně} složité a netrvat věčnost. Kopírovat celou matici sousednosti o milionu prvků kvůli jednomu přidanému uzlu rozhodně nebude správnou cestou.

Zadání práce požaduje, aby vrcholy i hrany mohly být nějakým, nespecifikovaným, způsobem ohodnoceny. Opět bude vhodné uvažovat, kvůli obecnosti řešení, maximalistickou variantu. Budeme předpokládat, že každá z hran i vrcholů může být ohodnocena libovolným počtem vlastností libovolného typu. Z tohoto rozhodnutí plyne, že by vrchol i hrana měly mít svou vlastní třídu (ve významu objektového programování), aby se s nimi dalo jednodušeji manipulovat.

Jelikož budou vrcholy a hrany v interpretu zpřístupnitelné i jako samostatné proměnné, je třeba, aby si nějakým způsobem pamatovaly, ke kterému grafu patří. Tento požadavek bude nejspíše řešen uložením ukazatele na objekt grafu do atributu třídy. Vrcholy i hrany by dále měly být v grafu schopné identifikovat sebe sama. Pokud by byl graf implementován například maticí sousednosti, je tento požadavek naprosto zásadní, protože bez něj by například nebylo možné najít sousedy daného uzlu.

Další z důležitých otázek je reprezentace množin uzlů a hran, přidávání a odebírání prvků, množinové a jiné operace. Výhodou bude, když budou množiny reprezentované identicky jako celý graf, protože spousta kódu potom zůstane ekvivalentní. Předpokládá se časté přidávání a odebírání prvků, a proto by měly být tyto operace jednoduché a rychlé.

Předpokládaná velikost grafů jsou miliony vrcholů a hran, čímž vznikají ob\-rov\-ské pa\-mě\-ťo\-vé nároky. Každé z primitiv může být odkazováno proměnnou v interpretu, či jiného místa, a proto bude pravděpodobně potřeba nějaký druh paměťového managementu, který zamezí chybám při práci s dynamickou pamětí.


\subsection{Reprezentace grafu}

Existuje několik možností, jak reprezentovat graf v programu. V teorii grafů bývají nejčastěji zmi\-ňo\-vá\-ny maticové reprezentace a spojové seznamy, ale existují i další, méně obvyklé, způsoby.

% TODO: znak x v matematice

\begin{itemize}
\item matice inicidence $|U|$ x $|H|$
\item matice sousednosti $|U|$ x $|U|$
\item spojové seznamy -- seznam následníků apod.
\item jiné reprezentace
\end{itemize}

Cílem této části bude najít nejvhodnější reprezentaci grafu, kterou by bylo možné použít ve specifické oblasti interpretu.


\subsubsection{Standardní maticové reprezentace}

% TODO: znak x v matematice

Matice sousednosti je v grafové teorii definována jako dvourozměrné pole $|U|$ x $|U|$. V jazyce C++ s použitím knihovny STL by mohly být atributy třídy grafu definovány například následovně.

\begin{verbatim}
class Graph
{
    vector<Vertex*> m_vertices;
    vector< vector<Edge*> > m_edges;
};
\end{verbatim}

Parametry datových kontejnerů nemohou být primitivní datové typy, protože každý vrchol i hrana musí umět ukládat dodatečné vlastnosti typu klíč--hodnota definované v požadavcích na systém.

Na první pohled se zdá, že by mohlo být výhodné použít tuto reprezentaci, nicméně existuje několik výrazných problémů. Největším z nich jsou paralelní hrany, protože počáteční a koncový vrchol hranu neurčují jednoznačně. Řešením by mohla být trojrozměrná matice a trojrozměrné indexy, je však vidět, že toto řešení rozhodně není hezké.

\begin{verbatim}
    vector< vector< vector<Edge*> > > m_edges;
\end{verbatim}

Další velkou nevýhodou je příliš složité přidávání a mazání vrcholů a vyplývající časté realokace velkých bloků paměti. Toto řešení by tedy bylo vhodné spíše pro statické grafy, které se na začátku vytvoří a pak zůstanou nezměněny až do konce algoritmu.

Problémem je i složité procházení vrcholů a hran a hledání sebe sama v grafu. Každý vrchol a hrana musí mít u sebe uložen index do matice reprezentující graf, který se navíc může při přidání nového vrcholu u všech již existujících vrcholů posunout. Tímto by se výrazně zvýšily paměťové i výpočetní nároky.

Další problémy pravděpodobně vzniknou při vytváření množin vrcholů a hran, které budou mít naprosto odlišnou implementaci vzhledem k vlastní třídě grafu. Paměťový management by býl extrémně složitý a náchylný k chybám.

Výše uvedená diskuze odhalila množství nepřekonatelných problémů, které by vznikly při použití matice sousednosti. Dá se také předpokládat, že se úplně stejné problémy objeví i u matice inicidence a všude tam, kde je vlastní struktura grafu, návaznost vrcholů a hran, definovaná centrálně ve třídě grafu.


\subsubsection{Reprezentace množinami vrcholů a hran}

Tato reprezentace grafů se ve školách neučí, ale v tomto konkrétním specifickém případě, intepretu, je velice elegantní. Samotný nápad vznikl při odhalení slepé uličky u maticových reprezentací, které strukturu grafu definují centrálně v jedné datové struktuře. Bylo potřeba najít nějaké distribuované řešení.

Datové položky grafu budou tvořit pouze dvě množiny vrcholů a hran. Na tomto místě by se dal použít i jiný datový kontejner, avšak množiny se objeví i v jiných třídách a tam už budou nutné. Dá se říci, že ani tyto dva kontejnery ukazatelů by nemusely být ve třídě grafu definovány, nicméně je třeba nějakým způsobem uvolňovat dynamickou paměť, uložení pointerů je proto nezbytné.

\begin{verbatim}
class Graph
{
    set<Vertex*> m_vertices;
    set<Edge*> m_edges;
};
\end{verbatim}

Vlastní struktura grafu, čili propojení vrcholů hranami, je definovaná ne ve třídě grafu, ale přímo ve třídách vrcholů a hran. Vrchol obsahuje množinu hran, které s ním incidují a hrany ukládají ukazatele na svůj počáteční a koncový uzel. Referenci na graf je nutné uchovávat kvůli interpretu.

\begin{verbatim}
class Vertex
{
    Graph* m_graph;
    set<Edge*> m_edges;
};

class Edge
{
    Graph*  m_graph;
    Vertex* m_begin
    Vertex* m_end;
};
\end{verbatim}

Hlavní výhodou této reprezentace je možnost práce s naprosto obecným grafem, nemusíme se starat o paralelní hrany ani smyčky nad uzly. Už bylo zmíněno, že druhý typ reprezentace, matice sousednosti, ve své standardní verzi neumí pracovat s paralelními hranami.

Druhou obrovskou výhodou je ekvivalentní implementace grafu a množin jeho uzlů a hran. Není nutné programovat identické operace dvakrát a poté je navíc složitě napojovat na sebe. Výhodou je i přirozená a jednoduchá iterovatelnost množin, díky níž nebude složité implementovat procházení grafu pomocí cyklu \texttt{foreach}.

Jedinou možnou nevýhodou je mírná duplicita informací při definici struktury gra\-fu, která je podobná obousměrně propojenému spojovému seznamu. Průchod je možný od uzlů k hranám a také naopak od hran k uzlům. V rozhraní tříd bude nutné ošetřit, aby kvůli této duplicitě nemohly vzniknout žádné problémy.


\subsubsection{Testovací implementace}

V následujícím výpisu kódu je ukázána až překvapivá elegance řešení na bázi množin vrcholů a hran ve spojení se standardní knihovnou STL a její šablonou \texttt{set}. Jsou ukázány čtyři funkce třídy grafu, které se starají o vytváření a mazání vrcholů a hran. Zdají natolik jednoduché, že veškeré komentáře jsou asi zbytečné.

\begin{verbatim}
Vertex* Graph::generateVertex(void)
{
    Vertex* vertex = new Vertex(this);
    m_vertices.insert(vertex);
    return vertex;
}

Edge* Graph::generateEdge(Vertex* begin, Vertex* end)
{
    Edge* edge = new Edge(this, begin, end);
    m_edges.insert(edge);

    begin->addEdge(edge);
    end->addEdge(edge);

    return edge;
}

void Graph::deleteVertex(Vertex* vertex)
{
    set<Edge*>& edges = vertex->getEdges();

    set<Edge*>::iterator it;
    for(it = edges.begin(); it != edges.end(); it++)
        deleteEdge(*it);

    m_vertices.erase(vertex);
    delete vertex;
}

void Graph::deleteEdge(Edge* edge)
{
    edge->getBeginVertex()->deleteEdge(edge);
    edge->getEndVertex()->deleteEdge(edge);
    m_edges.erase(edge);
    delete edge;
}
\end{verbatim}

Výhradně tyto čtyři funkce pracují s pamětí, a tudíž je možnost jejích úniků v této části aplikace vyloučená.

Implementace podmnožin vrcholů a hran je téměř identická jako implementace vlastního grafu. Jediný rozdíl se nachází v těchto čtyřech metodách, které u podmnožin nepracují s pamětí, ale pouze se starají o ukládání a vracení již existujících ukazatelů na objekty.

Přiřazování mezi proměnnými v interpretu není třeba nějak speciálně ošetřovat. Pokud je proměnná \texttt{vertex} vrcholem grafu, pak jeho přiřazení do jiné proměnné nevytváří v původním grafu ani v žádném jiném nový vrchol, nejde o hlubokou kopii. Protože žádný vrchol nemůže bez grafu existovat, je jasné, že proměnná \texttt{alias} z příkladu musí být identická k původnímu vrcholu. Stejnou úvahu lze provést i pro hrany.

\begin{verbatim}
vertex = g.generateVertex();
alias = vertex;
\end{verbatim}

Výše uvedený kód může vypadat jako nežádoucí a jeho použití okrajové, ale naprosto stejné operace se provádějí při předávání parametrů funkcím, a proto je dobré mít ověřeno, že při jejich volání nenastanou žádné problémy. Jak už bylo řečeno, o veškerou dynamicky alokovanou paměť grafu se stará třída \texttt{Graf} a nikdo jiný. Díky mělkým kopiím objektů není tudíž třeba ani garbage collectoru, ani chytrých ukazatelů s počítáním referencí.


\section{Proměnné ve skriptu, typy a operace}

\subsection{Implementace operací větvením}

Existují v zásadě dvě možnosti, jak implementovat sčítání, odčítání a ostatní operace nad hodnotami a proměnnými ve skriptu. První z nich předpokládá použití \texttt{unionu} a pomocné proměnné, která ukládá datový typ uložené hodnoty.

\begin{verbatim}
class CNodeValue
{
private:
    TYPE m_type;

    union
    {
    	bool m_b;
        int m_i;
        float m_f;
    };
};
\end{verbatim}

Toto řešení je funkční, nicméně při více podporovaných datových typech a operacích začíná být extrémně nepřehledné a náchylné k chybám. Každá z funkcí implementujících například některou aritmetickou operaci musí obsahovat větvení podle typu, navíc, v případě binární operace, vnořené. Příkladem budiž ukázka části kódu sčítání z autorova dřívějšího interpretu.

% TODO: literatura Borsch


\begin{verbatim}
const CNodeValue CNodeValue::operator+(const CNodeValue& object) const
{
    // ...

    switch(m_type)
    {
    case LEX_BOOL:
        switch(object.m_type)
        {
        case LEX_BOOL:
            return CNodeValue(m_b + object.m_b);
        case LEX_INT:
            return CNodeValue(m_b + object.m_i);
        case LEX_FLOAT:
            return CNodeValue(m_b + object.m_f);
        default:
            assert(false);
            return *this;
        }

        // ...
    }
}
\end{verbatim}

Tento kód ošetřuje sčítání boolean hodnoty s druhou boolean hodnotou, celým číslem a desetinným číslem. Jedná se pouze o část funkce, v případě tří různých datových typů by funkce obsahovala tři podobné sekce, ve výsledku devět, respektive šestnáct, podmínek.

Navrhovaný jazyk předpokládá dvanáct různých datových typů (viz sekce \ref{datove_typy_a_promenne} na straně \pageref{datove_typy_a_promenne}), což pouze pro sčítání dává celkem 144 větvení! Psát a poté udržovat podobný kód pro všechny operace je naprosto nereálné. Navíc přidání nového datového typu způsobí nutnost slo\-ži\-tých úprav všech existujících funkcí.


\subsection{Double dispatching pattern}

% TODO: reference na Bruce Eckel: Thinking in C++ 2, Multiple dispatching, str. 459

Odpovědí na všechny výše uvedené problémy je návrhový vzor \textit{Multiple dispatching}, který poskytuje možnost volání typových operací nad kombinací beztypových objektů. Základem je abstraktní třída \texttt{Value}, která deklaruje všechny potřebné operace -- pro každý datový typ a operaci jedna virtuální metoda, plus jedna čistě virtuální metoda pro neznámý datový typ.

\begin{verbatim}
class Value
{
    // +
    virtual PTR_Value add(const Value&     right) const = 0;
    virtual PTR_Value add(const ValueBool&  left) const;
    virtual PTR_Value add(const ValueInt&   left) const;
    virtual PTR_Value add(const ValueFloat& left) const;
    // ...
};
\end{verbatim}

Sčítání celého čísla s ostatními datovými typy může vypadat následovně. Nejdříve je nutné definovat sčítání celého čísla s neznámým datovým typem na pravé straně. V takovém případě funkce neví, jak tuto operaci provést, a proto požádá tento neznámý typ o sečtení se sebou samým, s tím, že mu oznámí, že se jedná o sčítání s celým číslem (typ ukazatele \texttt{this} je zde \texttt{ValueInt}).

Dejme tomu, že se jednalo také o celé číslo, zavolala se tedy třetí z uvedených metod a provedlo se sečtení celých čísel, jehož výsledkem je taktéž celé číslo. V tuto chvíli byly již všechny potřebné datové typy známé a operace se mohla vykonat.

\begin{verbatim}
PTR_Value ValueInt::add(const Value& right) const
{
    return right.add(*this);
}

PTR_Value ValueInt::add(const ValueBool& left) const
{
    return PTR_Value(new ValueInt(left.getVal() + m_val));
}

PTR_Value ValueInt::add(const ValueInt& left) const
{
    return PTR_Value(new ValueInt(left.getVal() + m_val));
}

PTR_Value ValueInt::add(const ValueFloat& left) const
{
    return PTR_Value(new ValueFloat(left.getVal() + m_val));
}
\end{verbatim}

Jednou z výhod Double dispatching patternu je také to, že není nutné definovat všechny metody pro všechny kombinace datových typů. Pokud operace s danými parametry nedává smysl, například sčítání čísla s vrcholem grafu, ponechá se vykonání operace na rodičovské třídě \texttt{Value}, jež může kupříkladu vypsat chybu a vrátit \texttt{NULL} hodnotu.

\begin{verbatim}
PTR_Value Value::add(const ValueGraph& /* left */) const
{
    cerr << "Operation is not supported" << endl;
    return VALUENULL;
}
\end{verbatim}

V případě přidání nového datového typu se žádná z již existujících funkcí nemění, pouze se do základní třídy dopíše nová virtuální operace a do potomků, kde to dává smysl, její implementace.


\section{Reprezentace skriptu a vykonávání}


\subsection{Procházení AST}

\begin{verbatim}
Jak uložit pozici ve zdrojových kódech?
	zaznamenat si pozici příkazu, bloku, funkce a ukládat to do
	těchto tříd ve stromě lexan vrací změnu pozice jako token,
	virtuální instrukce, problémy s gramatikou?
\end{verbatim}


\subsection{Virtuální procesor}

\subsection{Podpora debuggingu}

\begin{verbatim}
Implementace krokování
	rekurzivní volání execute() na stromovou strukturu, krokování pomocí
	synchronizace vláken lineární pole instrukcí, virtuální procesor

breakpoint(bool);
\end{verbatim}


\section{Úniky paměti, správce paměti}

\subsection{Garbage collector}

\subsection{Chytré ukazatele}

\begin{verbatim}
auto\_ptr ze STL nelze použít, protože...
http://www.davethehat.com/articles/smartp.htm
http://ootips.org/yonat/4dev/smart-pointers.html
http://www.josuttis.com/libbook/cont/countptr.hpp.html
\end{verbatim}

\section{Grafické uživatelské rozhraní}


\section{Generování kódu}

\begin{verbatim}
Automatické generování C/Java zdrojových kódů?
	aneb po zkušenostech s GWT proč ne? :-)
	komentáře asi ignorovat
\end{verbatim}


\section{Shrnutí}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Realizace}

% TODO: delete
Popis implementace / realizace se zaměřením na nestandardní části řešení.

\section{Základní kód a interpret pro příkazovou řádku}

\subsection{Inicializace statických objektů a úniky paměti}

\begin{verbatim}
init\_static\_objects.cpp
BaseObject
general.hpp ???
\end{verbatim}


\subsection{BaseObject::dump()}

\subsection{Lexikální analyzátor}

Z větší části převzatý Borsch a rozšířený
http://woq.nipax.cz/borsch/devel.php

\begin{verbatim}
// Identifikatory, retezec -> id
// Slozitost: generovani, pouziti id, zpetne dotazovani na retezce
http://zdrojak.root.cz/clanky/javascript-implementace-v-prohlizecich/
http://links.twibright.com/doc/projektova.pdf - links projektová
	dokumentace
http://links.twibright.com/doc/vyvojova.pdf - vývojová dokumentace
\end{verbatim}


\subsection{Gramatika, Bison}

\subsubsection{Pozice ve skriptu a AST}


\subsection{Proměnné ve skriptu, Value* hierarchie tříd}

\subsection{Abstraktní strom syntaxe, Node* hierarchie tříd}


\subsection{Funkce}

\subsubsection{Funkce zapsané ve skriptu}

\subsubsection{Zabudované funkce}


\subsection{Generátory zdrojových kódů}

\subsubsection{Operátory, zabudované funkce}

\subsubsection{C makra}
Great problems with debugging

\subsubsection{Skripty pro generování zdrojových kódů}


\subsection{Ladění intepretovaného skriptu}

\subsubsection{Vykonávání kódu}

Recursive traversion of AST, mutexes


\subsubsection{Zabudovaná funkce breakpoint()}

\subsubsection{Proměnné skriptu}

\subsubsection{Zásobník volání funkcí}


\subsection{Shrnutí}



\section{Grafické uživatelské rozhraní}

\subsection{Hlavní okno}

\subsection{Editor}

Code Editor Example
http://doc.trolltech.com/4.5/widgets-codeeditor.html

\subsection{Debugger}

\subsection{Vizualizace grafu}

\subsection{Shrnutí}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Testování}

% TODO: delete
\begin{itemize}
 \item Způsob, průběh a výsledky testování.
 \item Srovnání s existujícími řešeními, pokud jsou známy.
\end{itemize}

\section{Unit testy}

\section{Skriptové unit testy}

\section{Benchmarks}

\section{Použitelnost}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Závěr}

% TODO: delete
\begin{itemize}
\item Zhodnocení splnění cílů DP/BP a  vlastního přínosu práce (při formulaci je třeba vzít v potaz zadání práce).
\item Diskuse dalšího možného pokračování práce.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

%\bibliographystyle{abbrv}
%bibliographystyle{plain}
%\bibliographystyle{psc}
%\bibliographystyle{alpha} % [AutorRok]
%{
%\def\CS{$\cal C\kern-0.1667em\lower.5ex\hbox{$\cal S$}\kern-0.075em $}
%\bibliography{reference}
%}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\appendix


\chapter{Gramatika jazyka}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Hierarchie tříd}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Vývojové prostředí}

\section{Vývojové nástroje, verze}
\section{Kompilování}
\section{Spuštění, parametry příkazové řádky}
\section{Grafické uživatelské rozhraní}

base code for the application qt4/examples/mainwindows/mdi


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Seznam použitých zkratek}
\begin{description}
\setlength{\labelwidth}{2.5cm}
\setlength{\itemindent}{1.5cm}
\item[LALR] Look Ahead Left to Right (grammar type)
\item[STL] Standard Template Library
\item[AST] Abstract Syntax Tree
\item[CLI] Command Line Interface
\item[GUI] Graphics User Interface
\item[OOP] Object Oriented Programming
\item[I/O] Input/Output
\item[OpenGL] Open Graphics Library
\end{description}
\vdots


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{UML diagramy}

TODO: X36ASS


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Instalační a uživatelská příručka}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Obsah přiloženého CD}


\end{document}
