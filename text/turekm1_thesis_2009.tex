%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\documentclass[11pt,twoside,a4paper]{book}
\usepackage[czech, english]{babel}

%\usepackage[T1]{fontenc} % EC fonty
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
%\usepackage{indentfirst} % 1. odstavec jako v češtině.
\usepackage{tocloft}

\usepackage{k336_thesis_macros}
\usepackage{url}
\DeclareUrlCommand\url{\def\UrlLeft{<}\def\UrlRight{>} \urlstyle{tt}}

\usepackage[left=3.5cm,top=3.5cm,right=2cm,bottom=3cm]{geometry}

% http://www.fel.cvut.cz/cz/education/bk/prehled.html
\newcommand\TypeOfWork{Diplomová práce}
\newcommand\StudProgram{Elektrotechnika a informatika, strukturovaný,\\Navazující magisterský}
\newcommand\StudBranch{Výpočetní technika}
\newcommand\WorkTitle{Interpret grafových algoritmů}
\newcommand\FirstandFamilyName{Bc. Michal Turek}
\newcommand\Supervisor{RNDr. Marko Genyk-Berezovskyj}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\usepackage[
pdftitle={\WorkTitle},
pdfauthor={\FirstandFamilyName},
bookmarks=true,
colorlinks=true,
breaklinks=true,
urlcolor=red,
citecolor=blue,
linkcolor=blue,
unicode=true,
]
{hyperref}


% PRINT VERSION
%\usepackage[
%pdftitle={\WorkTitle},
%pdfauthor={\FirstandFamilyName},
%bookmarks=true,
%colorlinks=true,
%breaklinks=true,
%urlcolor=black,
%citecolor=black,
%linkcolor=black,
%unicode=true,
%]
%{hyperref}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\begin{document}

\selectlanguage{czech}
%\selectlanguage{english}

\iflanguage{czech}{
	 \newcommand\Department{Katedra počítačů}
	 \newcommand\Faculty{Fakulta elektrotechnická}
	 \newcommand\University{České vysoké učení technické v~Praze}
	 \newcommand\labelSupervisor{Vedoucí práce}
	 \newcommand\labelStudProgram{Studijní program}
	 \newcommand\labelStudBranch{Obor}
}{
	 \newcommand\Department{Department of Computer Science and Engineering}
	 \newcommand\Faculty{Faculty of Electrical Engineering}
	 \newcommand\University{Czech Technical University in Prague}
	 \newcommand\labelSupervisor{Supervisor}
	 \newcommand\labelStudProgram{Study Programme}
	 \newcommand\labelStudBranch{Field of Study}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\coverpagestarts


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\acknowledgements
\noindent

\noindent Rád bych poděkoval vedoucímu práce, RNDr. Marku Genyk-Berezovskému, za jeho při\-po\-mín\-ky a cenné rady.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\declaration{V~Praze dne \today}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\abstractpage
The core of this diploma thesis is design and implementation of a special programming language based on~C syntax, which is suited for the graph manipulations. Integrated development environment was created, it consists of a text editor for programmers, debugger and visualization window. The progress of the interpreted graph algorithm can be displayed using 3D graphics.

\vglue60mm

\noindent{\Huge \textbf{Abstrakt}}
\vspace{8ex}

\noindent
Jádrem diplomové práce je návrh a implementace speciálního programovacího jazyka za\-lo\-že\-né\-ho na syntaxi C, který slouží pro manipulaci s~grafy. Bylo vytvořeno integrované vývojové prostředí sestávající z~programátorsky zaměřeného textového editoru, debuggeru a vizualizačního okna. Průběh interpretovaného grafového algoritmu může být zobrazován pomocí 3D grafiky.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\cleardoublepage

\tableofcontents
\listoffigures
\listoftables


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\mainbodystarts

\parskip=5pt plus 3pt minus 3pt
\parindent=0em


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Úvod}

Algoritmy \textit{difúze} \cite{werner} slouží pro zpracování obrazů. Každý, kdo se jimi zabývá, ví, že fungují, ale nikdo přesně neví, proč vlastně fungují. Výstupem tohoto projektu je integrované vývojové prostředí pro psaní, ladění a vizualizaci průběhu takovýchto algoritmů.

Za vstupní data se považují pixely obrázku a výstupem je například, ve které jeho části se nachází objekt s~definovanými vlastnostmi, kde se vyskytuje pozadí a podobně. Obrázek je převeden na speciální graf s~několika vrcholy pro každý pixel a pospojovanými ohodnocenými hranami. Při zobrazení ve 3D prostoru může vytvořený graf vypadat podobně jako na schématu \ref{fig:graf_difuze}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=10cm]{img/graf_difuze.pdf}
\caption{Typ grafů, jež se používají pro difúzní algoritmy}
\label{fig:graf_difuze}
\end{center}
\end{figure}

Algoritmus pracuje s~lokálními částmi grafu, iterativně aktualizuje ohodnocení hran a končí poté, co je splněna globální podmínka. Difúze je velmi blízká \textit{loopy belief propagation} strategii \cite{belief_propagation}. Snaží se podobným způsobem o~totéž - tj. v~ohodnoceném grafu nalézt podgraf s~celkově maximální vahou hran a uzlů, přičemž množina přípustných podgrafů, na nichž se maximum hledá, je nějakým způsobem omezena. Zadání může být tedy zobecněno z~práce s~obrázky na jednoduché grafové operace.

Cílem diplomové práce je návrh a implementace jazyka založeného na syntaxi C, který slouží pro manipulaci s~grafy. Jazyk má podporu pro základní datové typy, jako jsou celá a desetinná čísla, řetězce, pole a struktury. Proměnné mohou být lokální i~globální, bez deklarací.

Výčet kontrolních struktur sestává z~\texttt{if-else} podmínek, \texttt{for}, \texttt{while} a \texttt{foreach} cyklů, deklarace funkcí a jejich volání. \texttt{Include} a \texttt{define} direktivy preprocesoru jsou implementovány na úrovni lexikálního analyzátoru. Jazyk nepodporuje ukazatele ani objektově orientované programování.

Speciální datové typy zahrnují grafy, vrcholy, hrany a jejich množiny. Interpret obsahuje zabudované funkce pro vytváření a rušení těchto proměnných, vracení sousedů daného vrcholu a další operace. Každému vrcholu a hraně může být přiřazen libovolný počet dalších hodnot, k~přístupu k~nim slouží jméno předávané tečkovou notací \texttt{objekt.vlastnost}. Speciální řídící struktury pro zpracování komplexních proměnných jsou implementovány na bázi iterátorů, jež jsou interně volané i~ve \texttt{foreach} cyklu.

Grafické uživatelské rozhraní sestává především z~programátorsky zaměřeného textového editoru, který poskytuje zvýrazňování syntaxe, číslování řádků, zvýraznění aktuálního řádku, automatické odsazování a inteligentní klávesu \texttt{Home}. Všechny ostatní části aplikace jsou tvořeny panely, jež mohou být uživatelem libovolně přesunuty na jiné místo, skryty a nebo také \textit{vytrhnuty} z~hlavního do samostatného okna. To je výhodné především při používání dvou monitorů. V~panelech je možné zobrazit výstup z~parsování a interpretace skriptu, zásobník volání funkcí, seznam definovaných proměnných a vizualizační okno.

Vizualizace jsou přímo propojené s~laděním skriptu. Vykonávání kódu může být pozastaveno breakpointem a poté krokováno s~možností vstupování do funkcí (step in), opuštění dané funkce (step out) či vykonání následujícího příkazu (step over). Při každém zastavení skriptu se aktualizuje panel zásobníku volání, seznam definovaných proměnných a vizualizace. Se zobrazeným grafem se dá následně otáčet, přibližovat ho, oddalovat a provádět další 3D operace. Graf může být nahrán jak kódem skriptu, tak explicitně uživatelem.

Základní kód interpretu a rozhraní pro příkazovou řádku je napsáno v~jazyce C++ s~využitím parser generátoru GNU Bison (LALR gramatika) a nezávisí na žádné další knihovně kromě standardní STL. Tato část je tudíž zkompilovatelná na libovolné platformě, pro kterou existuje C++ kompilátor. Grafická část aplikace používá Qt a vizualizace OpenGL, obě knihovny jsou dostupné na všech majoritních operačních systémech.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Popis problému, specifikace cíle}
\label{popis_problemu_specifikace_cile}

%\begin{itemize}
%\item Popis řešeného problému, vymezení cílů DP/BP a požadavků na implementovaný systém.
%\item Popis struktury DP/BP ve vztahu k vytyčeným cílům.
%\item Rešeršní zpracování existujících implementací, pokud jsou známy.
%\end{itemize}


\section{Požadavky na aplikaci}

Navrhněte a implementujte interpret jazyka, který bude zaměřen na práci s~grafy. Jazyk bude obsahovat základní datové struktury nezbytné pro manipulaci s~grafy a bude tak podporovat efektivní zápis grafových algoritmů. Interpret vybavte uživatelským rozhraním skládajícím se z~editoru pro zápis algoritmů a dále grafickým oknem interaktivně zobrazujícím průběh algoritmu nad konkrétním grafem. V~grafické části aplikace využijte knihovnu OpenGL.

Zásadní jsou neorientované grafy, implementace orientovaných je volitelná.

\subsection{Navrhovaný jazyk}

Jazykové konstrukce by měly být podobné jazyku C. Zahrnují základní datové typy, datové a řídící struktury

\begin{itemize}
\item celá a desetinná čísla,
\item pole,
\item podmínky, cykly, deklarace a volání funkcí,
\item výstup textu na vlastní konzoli,
\item direktiva \texttt{include} v~jednoduché verzi, tj. nikoli hlavičky, ale celé soubory.
\end{itemize}

Zvažte

\begin{itemize}
\item datový typ boolean,
\item znaky a řetězce, v~jednoduché formě bez složitých funkcí pro manipulaci,
\item ukazatele a struktury jako v~jazyce C,
\item objektově orientované vlastnosti,
\item čtení a zápis souborů, jde především o~načítání specifikací grafu z~externích souborů.
\end{itemize}

Specifické elementy jazyka zahrnují

\begin{itemize}
\item primitivní typy:
	\begin{itemize}
	\item graf, vrchol, hrana,
	\item množina vrcholů, množina hran,
	\end{itemize}
\item základní funkce:
	\begin{itemize}
	\item vytvoř/smaž graf/hranu/vrchol,
	\item ohodnoť hranu/vrchol,
	\item vrať všechny sousedy daného vrcholu,
	\item vytvoř/zruš množinu vrcholů/hran, přidej/odeber vrchol/hranu,
	\item vrať stupeň vrcholu,
	\end{itemize}
\item řídící struktury:
	\begin{itemize}
	\item pro všechny sousedy daného vrcholu vykonej \texttt{příkaz},
	\item pro všechny vrcholy/hrany v~dané množině vykonej \texttt{příkaz},
	\item pro všechny vrcholy/hrany grafu vykonej \texttt{příkaz}.
	\end{itemize}
\end{itemize}


\subsection{Textový editor}

Textový editor by měl být programátorsky zaměřený, zvýrazňování syntaxe je vítáno. Další vymoženosti podle dohody a možností.


\subsection{Zobrazovací jednotka, vizualizace}

Vizualizační jednotka zobrazuje aktuálně zpracovávaný graf ve 3D, nemusí to být editor, ve kterém je možné měnit strukturu grafu. Uživatel má možnost graf interaktivně natáčet, přibližovat, oddalovat a posouvat v~libovolném směru. Dále může zapnout a vypnout zobrazování jednotlivých částí grafu, aby bylo možné dosáhnout méně přeplněného výstupu.

Pokud bude v~jazyce možnost přidávat barevné (texturové) atributy vrcholům, hranám nebo jejich množinám, promítaly by se i~do zobrazení. Vizualizační okno má vlastní možnost načtení grafu, aplikace umožní volit, zda má algoritmus pracovat s~grafem, který je v~grafickém okně, nebo zda si jej načte sám podle zápisu v~kódu.


\subsection{Manipulace s~grafem, krokování skriptu}

Interpretace kódu může být krokována, při pozastavení se překreslí vizualizační okno a tím se aktualizuje i~pohled na graf. Dokud není vydán příkaz k~dalšímu kroku, je možné s~grafem posouvat, natáčet ho a podobně. Parametry samotného grafu během průběhu programu není vhodné měnit, avšak parametry zobrazení nejspíše ano (barvy, měřítka a podobně). Debugging není třeba nijak zvlášť podporovat, postačí konzole, kam si programátor může vypsat ladící a trasovací tisky.


%\subsection{Systémové požadavky}
%
%\begin{itemize}
%	\item Verze pro příkazovou řádku
%		\begin{itemize}
%		\item platformy \texttt{i386} a \texttt{amd64}, podpora dalších volitelná
%		\item operační systémy \texttt{GNU/Linux}, \texttt{MS Windows} (založený na NT) a \texttt{MacOS}, podpora dalších volitelná
%		\item procesor min. 1 GHz
%		\item operační paměť min. 2 GB RAM, v grafech se předpokládají miliony vrcholů
%		\end{itemize}
%
%	\item Grafická verze
%		\begin{itemize}
%		\item grafická karta s podporou OpenGL (např. \texttt{nVidia GeForce 2} a novější)
%		\item nainstalované OpenGL ovladače a Qt4 knihovny
%		\item rozlišení monitoru min. 1024x768
%		\end{itemize}
%\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Analýza a návrh řešení}

% Analýza a návrh implementace (včetně diskuse různých alternativ a volby implementačního prostředí).

Základním cílem tohoto projektu je vyvinout integrované vývojové prostředí pro programovací jazyk orientovaný na manipulace s~grafy. Tato komplexní úloha může být rozdělena na několik oddělených částí, které jsou řešeny v~následujícím pořadí:

\begin{enumerate}
\item Návrh jazyka, který odpovídá všem požadavkům.
\item Návrh reprezentace grafů v~aplikaci, ohled na přístup z~interpretu.
\item Implementace lexikálního analyzátoru a parseru.
\item Implementace interpretu pro příkazovou řádku.
\item Návrh a implementace grafického vývojového prostředí.
\item Implementace vizualizačního okna, propojení s~interpretem.
\end{enumerate}


\section{Volba jazyka a knihoven pro implementaci}

Na samém začátku je možné pro tvorbu sys\-té\-mo\-vých aplikací uvažovat tři běžně používané jazyky: C++, Javu a C\#. Třetí z~nich může být automaticky vyškrtnut, protože neodpovídá základnímu požadavku na přenositelnost. Jazyk C++ je portovatelný na úrovni zdrojových kódů a Java na úrovni byte kódu. Žádné skriptovací jazyky, jako například Perl a Python, nejsou uvažovány. Ačkoli mnoho vývojářů může tvrdit přesný opak, nejsou příliš vhodné pro tak velkou aplikaci a psát interpret v~interpretovaném jazyce není příliš vhodné.

Obrovskými výhodami Javy je její automatický správce paměti a spousta existujících knihoven a frameworků. Na druhou stranu, kvůli kompilaci do strojového kódu a z~ní vyplývající rychlosti provádění, je naprostá většina kompilátorů a interpretů napsaná v~C nebo C++.

Autor práce preferuje při vývoji systémových aplikací C++ a má s~ním také mnohem více zku\-še\-nos\-tí, a proto byl nakonec zvolen právě tento jazyk. Žádná knihovna, kromě standardního STL, není při tvorbě základního kódu použita -- interpret pro příkazovou řádku by měl mít co nejméně externích závislostí. Díky tomu je bez větších problémů portovatelný na všechny platformy, pro které existuje C++ kompilátor.

Grafická část aplikace je naprogramovaná s~použitím knihovny Qt. Je jednou z~nejlépe navržených knihoven pro tvorbu GUI aplikací, přenositelná na všechny majoritní operační systémy a bezplatná pro nekomerční použití. Vizualizace grafů používají OpenGL, jedná se o~standard pro 3D grafiku. Druhá možná volba, Direct3D, není použitelná na ne-Microsoft platformách, a proto je zbytečné o~ní uvažovat.


\section{Návrh a specifikace vytvářeného jazyka}

Jak už bylo zmíněno, syntaxe jazyka je z~větší části založena na všeobecně známém C, což programátorům přináší výhodu rychlého učení. Jazyk rozlišuje malá a velká písmena, je procedurální a nepodporuje objektově orientované vlastnosti.


\subsection{Datové typy a proměnné}
\label{datove_typy_a_promenne}

Proměnné se nedeklarují, v~průběhu vykonávání skriptu mohou libovolně měnit svůj datový typ. Uvnitř interpretu jsou rozlišovány typy \texttt{null}, \texttt{bool}, \texttt{int}, \texttt{float}, \texttt{string}, \texttt{struct}, \texttt{array}, \texttt{graph}, \texttt{vertex}, \texttt{edge} a \texttt{set}. Jazyk nepodporuje modifikátory typu, jako jsou například \texttt{unsigned} nebo \texttt{const}, protože nepřinášejí žádné výrazné vylepšení, programátor se musí obejít bez nich.

Viditelnost proměnných je definována na úroveň funkcí, tudíž opuštění daného bloku (na\-pří\-klad cyklu) nezpůsobuje zrušení v~něm používaných proměnných. Globální pro\-měn\-nou je možné ve funkci zpřístupnit po vzoru jazyka PHP klíčovým slovem \texttt{global}.

\begin{verbatim}
function example()
{
    global g_var;
    g_var = "some value";
}
\end{verbatim}

Při úvahách o~deklaracích proměnných byly zvažovány možnosti

\begin{itemize}
\item jako v~C -- povinná,
\item jako v~C -- nepovinná,
\item jako v~JavaScriptu pomocí klíčového slova \texttt{var} -- nepovinná,
\item bez deklarací.
\end{itemize}

Na první pohled je jasné, že prostřední dvě možnosti nepřinášejí nic užitečného. Pokud jsou deklarace volitelné, nejde těžit z~jejich výhod a pouze přidávají nová klíčová slova, což je patrné především u~JavaScriptového způsobu.

Výhodou deklarací je snadná detekce mnoha typů chyb a případně možnost větších optimalizací. Na druhou stranu příliš svazují, což je patrné především u~skriptovacích jazyků, které se snaží o~co nejmenší množství kódu na co největší funkcionalitu. Právě z~tohoto důvodu byla zvolena verze bez deklarací.

Poznámka na okraj. Deklarace by se mohly hodit i~pro automatizovaný překlad do jiných běžně používaných jazyků, než ve kterém byl napsán vlastní algoritmus. V~tomto případě by se pravděpodobně jednalo o~kompilovatelné C++ nebo Javu. Tato myšlenka je inspirována Google Web Toolkitem, který překládá javovské programy do HTML, CSS a JavaScriptu, nejedná se o~nic nereálného.


\subsection{Operátory}

Jazyk podporuje prakticky všechny operátory z~jazyka C s~výjimkou operátoru čárky a bitových operátorů. Priority jsou stejné jako v~C.

\begin{itemize}
\item unární operátory:
	\begin{itemize}
	\item \texttt{-}, \texttt{!}, \texttt{++}, \texttt{--}
	\end{itemize}
\item binární operátory:
	\begin{itemize}
	\item aritmetické: \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{\%}
	\item přiřazovací: \texttt{=}, \texttt{+=}, \texttt{-=}, \texttt{*=}, \texttt{/=}, \texttt{\%=}
	\item přiřazení reference: \texttt{\&=}
	\item logické: \texttt{==}, \texttt{!=}, \texttt{<=}, \texttt{>=}, \texttt{<}, \texttt{>} \texttt{\&\&}, \texttt{||}
	\item přístup k~prvkům: \texttt{.}, \texttt{[]}
	\end{itemize}
\item ternární operátor:
	\begin{itemize}
	\item \texttt{? :}
	\end{itemize}
\end{itemize}


\subsection{Řídící struktury}

Zápis podmínek a cyklů je naprosto stejný jako v~C, programátor může použít konstrukce \texttt{if}, \texttt{if-else}, \texttt{for} a \texttt{while}. Vícenásobné větvení \texttt{switch} není implementováno, protože je bez problémů nahraditelné vnořenými \texttt{if-else} podmínkami.

Jazyk dále přináší cyklus \texttt{foreach}, který umí iterovat přes všechny prvky složeného datového typu, jímž může být například pole, struktura a množina, ale také vlastnosti vrcholů a hran. Cyklus \texttt{foreach} interně používá iterátory.

\begin{verbatim}
foreach(item; iterableObject)
{
    println(item);
}
\end{verbatim}

Předčasné ukončení cyklu je možné provést klasicky pomocí strukturovaných skoků \texttt{break} a \texttt{continue}.


\subsection{Funkce}

Funkce se ve skriptu deklarují podobně jako v~jazyce PHP. Klíčové slovo \texttt{function} následuje jméno funkce, v~kulatých závorkách čárkami oddělený seznam parametrů a ve složených závorkách tělo funkce. Při parsování nezáleží na pořadí funkcí v~souboru, interpretace začíná až po zpracování celého zdrojového kódu, kdy už jsou všechny dostupné. Samotný skript se spouští funkcí \texttt{main(argv)} s~polem argumentů v~parametru.

U~volání funkcí jsou k~dispozici dvě ekvivalentní syntaxe. V~první verzi je možné všechny parametry předat klasicky do kulatých závorek, u~druhého způsobu je první parametr zapsán tečkovou notací před jméno funkce a celý zápis potom vypadá jako volání metody nad daným objektem. Forma je inspirována jazykem Python a jeho \texttt{self} parametrem u~metod třídy.

\begin{verbatim}
function someFunc(parameter1, parameter2, parameter3)
{
    // ...
}

someFunc(object, parameter2, parameter3);
object.someFunc(parameter2, parameter3);

someFunc(objects[2].position.x, parameter2, parameter3);
objects[2].position.x.someFunc(parameter2, parameter3);
\end{verbatim}

Veškeré parametry se předávají hodnotou. Při návrhu bylo zvažováno také předávání odkazem, tato technika se používá především k~vracení několika hodnot z~funkce najednou a omezení velikosti kopírovaných dat. Autor ale nakonec došel k~závěru, že není vyloženě nutná, hodnoty se mohou uložit do struktury nebo pole a vrátit ve formě kontejneru. Jednoduchost jazyka a nedeklarativnost proměnných k~tomu přímo vybízí.


\subsection{Preprocesor}
\label{preprocesor}

Pro zahrnutí zdrojového souboru do překladu, například dodatečné knihovny funkcí, slouží příkaz \texttt{include} s~cestou a jménem souboru v~parametru. Nové makro, respektive symbolickou konstantu, je možné definovat příkazem \texttt{define}. Kdykoli se ve zdrojovém souboru objeví specifikovaný identifikátor, je automaticky nahrazen hodnotou makra. Obě konstrukce se zpracovávají na úrovni lexikálního analyzátoru, parseru se předává až výsledný proud tokenů.

\begin{verbatim}
include("filename");
define("name", "value");
\end{verbatim}


\subsection{Datové kontejnery}
\label{datove_kontejnery}

Základními datovými kontejnery na úrovni jazyka zůstávají pole, struktury a množiny, ty se však dají jednoduše rozšířit. Zásobník a fronta se z~pole vytvoří definováním operací \texttt{pushFront()}, \texttt{push\-Back()}, \texttt{popFront()}, \texttt{popBack()}, \texttt{front()} a \texttt{back()}. Struktura se může bez jakýchkoli změn po\-u\-ží\-vat jako mapa (asociativní pole) a s~její pomocí se dá jednoduše implementovat i~spojový seznam.

Na rozdíl od jiných skriptovacích jazyků není definována speciální syntaxe pro deklarace a vytváření netriviálních typů proměnných. Pro zachování jednoduchosti stačí pouze zavolat zabudované funkce \texttt{array()}, \texttt{struct()} a další, které vrátí nově vytvořený objekt daného datového typu, a ná\-sled\-ně jej začít používat.

\begin{verbatim}
arr = array(5);
arr[0] = "item";
arr[1] = array(10);
arr[3] = 3.14;

st = struct();
st.name = "item";
st.valid = true;
\end{verbatim}

V~prvcích polí i~struktur mohou být uloženy libovolné datové typy -- tímto se dají například vytvořit dvou a vícerozměrná pole, spojové seznamy, stromy a další běžné datové struktury, hloubka zanoření není nijak omezena. V~programátorem neinicializované položce se vždy nachází hodnota \texttt{null}, datový typ prvků je možné kdykoli změnit pouhým přiřazením.


\subsection{Grafy, vrcholy a hrany}

První operací při práci s~grafovými vlastnostmi jazyka je vždy volání zabudované funkce \texttt{graph()}, která vytvoří objekt grafu. Od této chvíle se může přistoupit k~definici vrcholů a hran a následné práci s~nimi. Vrcholy i~hrany se zároveň chovají jako struktury, tudíž je u~nich možné používat libovolný počet libovolně pojmenovaných vlastností.

\begin{verbatim}
g = graph();
v1 = g.generateVertex();
v2 = g.generateVertex();
e1 = g.generateEdge(v1, v2);

v1.color = "red";
v2.visited = false;
e1.value = 3.14;

foreach(vertex; v1.getNeighbors())
    doSomething(vertex);
\end{verbatim}

Pro vytváření množin vrcholů a hran slouží zabudovaná funkce \texttt{set()}, jež se chová podobně jako pole a struktury popsané v~kapitole \ref{datove_kontejnery} na straně \pageref{datove_kontejnery}. Tento kontejner není určen výhradně pro grafové objekty, ale může ukládat libovolné datové typy, včetně různých kombinací.


\subsection{Ukázka skriptu}

Příkladem skriptu zapsaného ve vytvářeném jazyce budiž rekurzivní pro\-hle\-dá\-vá\-ní grafu do hloubky. Parametrem uživatelsky definované funkce \texttt{dfs()} je libovolný vrchol grafu. Pokud už byl daný vrchol navštíven, větev procházeného stromu se ukončí, v~opačném případě se označí vrchol za navštívený a funkce se rekurzivně zavolá nad všemi jeho sousedy.

\begin{verbatim}
define("NEW", "0");
define("CLOSED", "1");

// Recursive depth first search
function dfs(v)
{
    if(v.state == CLOSED)
        return;

    v.state = CLOSED;

    foreach(neighbor; v.getNeighbors())
        dfs(neighbor);
}
\end{verbatim}

Výše definovaný algoritmus funguje nad všemi orientovanými i~neorientovanými spojitými grafy. Od začátku vývoje se předpokládá načítání grafů z~externích souborů, nicméně jejich vytváření je možné i~v~kódu programu.


\section{Analýza reprezentace grafu}

\subsection{Obecné požadavky}

Jedním ze základních kamenů vytvářené aplikace je reprezentace grafů, vrcholů, hran a jejich množin v~kódu programu. Přímo ze zadání práce vyplývá několik skutečností. Následuje stručný přehled požadavků, který bude následně rozebírán a diskutován. Jedná se~o

\begin{itemize}
\item typ podporovaných grafů,
\item zapnutí a vypnutí orientace, inverze orientace,
\item dynamičnost grafů, složitost vytváření nových vrcholů a hran,
\item vlastnosti vrcholů a hran,
\item zpětná reference na objekt celého grafu,
\item identifikovatelnost sebe sama v~grafu,
\item přístup k~sousedním vrcholů,
\item přístup k~počátečnímu a koncovému vrcholu hrany,
\item reprezentace množin vrcholů a hran, množinové operace,
\item iterace přes všechny vrcholy/hrany grafu/množiny,
\item paměťový management, paměťové nároky.
\end{itemize}

První a nejdůležitější z~otázek se ptá, jakou třídu grafů je třeba podporovat. Jelikož je program psán úplně od začátku a neexistují žádná omezení plynoucí z~již existujícího kódu a napojování se na něj, je rozumnou volbou uvažovat maximální možnou množinu všech grafů. Ta zahrnuje orientované i~neorientované grafy, spojité i~nespojité, několik paralelních hran mezi dvěma vrcholy a samozřejmě také smyčky nad vrcholem -- tj. hrana začíná i~končí ve stejném vrcholu. Dále v~textu uvidíme, že toto rozhodnutí silně omezí možné způsoby implementace, popř. je výrazně zkomplikuje.

Ačkoli se předpokládají spíše statické grafy, které se na začátku vytvoří a dále se už nemění, přidávání a mazání vrcholů a hran by mělo být \textit{rozumně} složité. Kopírovat matici sousednosti o~milionu prvků kvůli jednomu přidanému vrcholu rozhodně není správnou cestou.

Zadání práce požaduje, aby vrcholy i~hrany mohly být nějakým, nespecifikovaným, způsobem ohodnoceny. Opět je vhodné uvažovat maximalistickou variantu. Předpokládáme, že každá z~hran může být ohodnocena libovolným počtem vlastností libovolného typu, to samé platí pro vrcholy. Z~tohoto rozhodnutí plyne, že by vrchol i~hrana měly mít svou vlastní třídu (ve významu objektového programování), aby se s~nimi dalo jednodušeji manipulovat.

Jelikož jsou vrcholy a hrany v~interpretu zpřístupnitelné i~jako samostatné proměnné, je třeba, aby si nějakým způsobem pamatovaly, ke kterému grafu patří. Tento požadavek se řeší uložením ukazatele na objekt grafu do atributu třídy. Vrcholy i~hrany by dále měly být v~grafu schopny identifikovat sebe sama. Pokud by byl graf implementován například maticí sousednosti, je tento požadavek naprosto zásadní, protože bez něj by například nebylo možné najít sousedy daného vrcholu.

Další z~důležitých otázek je reprezentace množin vrcholů a hran, přidávání a odebírání prvků, množinové a jiné operace. Pokud by byly množiny reprezentované identicky jako celý graf, zůstane spousta kódu ekvivalentní nebo alespoň podobná. Předpokládá-li se časté přidávání a odebírání prvků, měly by být tyto operace jednoduché a rychlé.

Očekávaná velikost grafů jsou miliony vrcholů a hran -- ob\-rov\-ské pa\-mě\-ťo\-vé nároky. Každé z~primitiv může být odkazováno proměnnou v~interpretu, či jiného místa, a proto je zajisté potřeba nějaký druh paměťového managementu, který zamezí chybám při práci s~dynamickou pamětí.


\subsection{Reprezentace grafu}

Existuje několik možností, jak reprezentovat graf v~programu. Při výuce teorie grafů bývají nejčastěji zmi\-ňo\-vá\-ny maticové reprezentace a spojové seznamy, ale existují i~další, méně obvyklé, způsoby. Označme množinu vrcholů, resp. hran, symbolem $V$, resp. $H$. Pro uložení grafu se běžně používají

\begin{itemize}
\item matice incidence $|V| \times |H|$,
\item matice sousednosti $|V| \times |V|$,
\item spojové seznamy -- seznam následníků apod.,
\item jiné reprezentace.
\end{itemize}

Cílem této části je najít nejvhodnější reprezentaci grafu, kterou by bylo možné použít ve specifické oblasti interpretu.


\subsubsection{Standardní maticové reprezentace}

Matice sousednosti je v~grafové teorii definována jako dvourozměrné pole $|U| \times |U|$. V~jazyce C++ s~použitím knihovny STL by mohly být atributy třídy grafu definovány například následovně.

\begin{verbatim}
class Graph
{
    vector<Vertex*> m_vertices;
    vector< vector<Edge*> > m_edges;
};
\end{verbatim}

Parametry datových kontejnerů nemohou být primitivní datové typy, protože každý vrchol i~každá hrana musejí umět ukládat dodatečné vlastnosti typu klíč--hodnota definované v~požadavcích na systém.

Na první pohled se zdá, že by mohlo být výhodné použít tuto reprezentaci, nicméně existuje několik výrazných problémů. Největším z~nich jsou paralelní hrany, protože počáteční a koncový vrchol neurčují hranu jednoznačně. Řešením by mohlo být přidání dodatečného vrcholu podle schématu \ref{fig:parallel_edges}, kterým se dvojice paralelních hran rozbije na tři jednoznačně identifikovatelné hrany. Druhou, horší, možností zůstává trojrozměrné pole a trojrozměrné indexy. Ani jedno z~řešení rozhodně není hezké.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=10cm]{img/parallel_edges.pdf}
\caption{Rozlišení dvou paralelních hran pomocí dodatečného vrcholu}
\label{fig:parallel_edges}
\end{center}
\end{figure}

\begin{verbatim}
    vector< vector< vector<Edge*> > > m_edges;
\end{verbatim}

Další nevýhodou je příliš složité přidávání a mazání vrcholů a z~toho vyplývající časté realokace velkých bloků paměti. Toto řešení by tedy bylo vhodné spíše pro statické grafy, které se na začátku vytvoří a pak zůstanou nezměněny až do konce algoritmu.

Problémem je i~složité procházení vrcholů a hran a hledání sebe sama v~grafu. Každý vrchol a hrana musí mít u~sebe uložen index do matice reprezentující graf, který je navíc nutné aktualizovat při libovolné změně matice sousednosti. Kupříkladu schéma \ref{fig:update_indices} ukazuje problémy s~mazáním hrany. Tímto by se výrazně zvýšily nejen paměťové, ale i~výpočetní nároky.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=7cm]{img/update_indices.pdf}
\caption{Vrcholy, které musejí být aktualizovány po smazání některého z~nich}
\label{fig:update_indices}
\end{center}
\end{figure}

Další problémy pravděpodobně by pravděpodobně vznikly při vytváření množin vrcholů a hran, které by měly naprosto odlišnou implementaci vzhledem k~vlastní třídě grafu. Paměťový management by byl extrémně složitý a snadno náchylný k~chybám.

Výše uvedená diskuze odhalila množství nepřekonatelných problémů, které by vznikly při použití matice sousednosti. Dá se také předpokládat, že se úplně stejné problémy objeví i~u~matice incidence a všude tam, kde je vlastní struktura grafu, návaznost vrcholů a hran, definovaná centrálně ve třídě grafu.


\subsubsection{Reprezentace množinami vrcholů a hran}
\label{reprezentace_mnozinami_vrcholu_a_hran}

Tato reprezentace grafů se učí spíše zřídka, nicméně v~tomto konkrétním případě (interpretu), vychází jako velice elegantní. Samotný nápad vznikl při odhalení slepé uličky u~maticových reprezentací, které strukturu grafu definují centrálně v~jediné datové struktuře. Bylo potřeba najít nějaké distribuované řešení.

Datové položky třídy grafu jsou tvořeny pouze dvěma množinami nebo seznamy vrcholů a hran. Dá se říci, že ani tyto dva kontejnery ukazatelů by nemusely být ve třídě grafu definovány, nicméně je třeba nějakým způsobem uvolňovat dynamickou paměť, uložení pointerů je proto nutností.

\begin{verbatim}
class Graph
{
    set<Vertex*> m_vertices;
    set<Edge*> m_edges;
};
\end{verbatim}

Vlastní struktura grafu je definovaná ne v~jeho třídě, ale přímo u~vrcholů a hran. Vrchol obsahuje množinu hran, které s~ním incidují, a hrany ukládají ukazatele na svůj počáteční a koncový vrchol. Referenci na graf je nutné uchovávat kvůli interpretu.

\begin{verbatim}
class Vertex
{
    Graph* m_graph;
    set<Edge*> m_edges;
};

class Edge
{
    Graph*  m_graph;
    Vertex* m_begin
    Vertex* m_end;
};
\end{verbatim}

Hlavní výhodou této reprezentace je možnost práce s~naprosto obecným grafem, není třeba se starat o~paralelní hrany ani smyčky nad vrcholy. Už bylo zmíněno, že druhý typ reprezentace, matice sousednosti, neumí reprezentovat paralelní hrany.

Druhá obrovská výhoda samozřejmě spočívá v~ekvivalentní implementaci grafu a množin jeho vrcholů a hran. Není nutné programovat identické operace dvakrát a poté je navíc složitě napojovat na sebe. Výhodou je i~přirozená iterovatelnost množin, díky níž nebylo složité implementovat procházení grafu pomocí cyklu \texttt{foreach}.

Jedinou možnou nevýhodou je mírná duplicita informací při definici struktury gra\-fu, která je podobná obousměrně propojenému spojovému seznamu. Průchod je možný od vrcholů k~hranám a také naopak od hran k~vrcholům. V~rozhraní tříd je nutné ošetřit, aby kvůli této duplicitě nemohly vzniknout žádné problémy.


\subsubsection{Testovací implementace}

V~následujícím výpisu kódu je ukázána až překvapivá elegance řešení na bázi množin vrcholů a hran ve spojení se standardní knihovnou STL a její šablonou \texttt{set}. Jsou ukázány čtyři metody třídy grafu, které se starají o~vytváření a mazání vrcholů a hran. Zdají se natolik jednoduché, že veškeré komentáře jsou asi zbytečné.

\begin{verbatim}
Vertex* Graph::generateVertex(void)
{
    Vertex* vertex = new Vertex(this);
    m_vertices.insert(vertex);
    return vertex;
}

Edge* Graph::generateEdge(Vertex* begin, Vertex* end)
{
    Edge* edge = new Edge(this, begin, end);
    m_edges.insert(edge);

    begin->addEdge(edge);
    end->addEdge(edge);

    return edge;
}

void Graph::deleteVertex(Vertex* vertex)
{
    set<Edge*> edges = vertex->getEdges();
    for(set<Edge*>::iterator it = edges.begin(); it != edges.end(); ++it)
        deleteEdge(*it);

    m_vertices.erase(vertex);
    delete vertex;
}

void Graph::deleteEdge(Edge* edge)
{
    edge->getBeginVertex()->deleteEdge(edge);
    edge->getEndVertex()->deleteEdge(edge);
    m_edges.erase(edge);
    delete edge;
}
\end{verbatim}

Výhradně tyto čtyři funkce pracují při vytváření a mazání vrcholů a hran s~pamětí, a tudíž je možnost jejích úniků v~této části aplikace vyloučená.

Implementace podmnožin vrcholů a hran je téměř identická jako implementace vlastního grafu. Jediný rozdíl se nachází v~těchto čtyřech metodách -- nepracují s~pamětí, ale pouze se starají o~ukládání a vracení již existujících ukazatelů na objekty.

Přiřazování mezi proměnnými v~interpretu není třeba nějak speciálně ošetřovat. Pokud je proměnná \texttt{vertex} vrcholem grafu, pak jeho přiřazení do jiné proměnné nevytváří v~původním grafu ani v~žádném jiném nový vrchol, nemůže jít o~hlubokou kopii. Protože žádný vrchol nemůže bez grafu existovat, je jasné, že proměnná \texttt{alias} z~příkladu níže musí odkazovat na stejný vrchol  jako proměnná \texttt{vertex}. Stejnou úvahu lze provést i~pro hrany.

\begin{verbatim}
vertex = g.generateVertex();
alias = vertex;
\end{verbatim}

Výše uvedený kód může vypadat jako nežádoucí a jeho použití okrajové, ale naprosto stejné operace se provádějí při předávání parametrů funkcím, a proto je dobré mít ověřeno, že při jejich volání nenastanou žádné problémy. Jak už bylo řečeno, o~veškerou dynamicky alokovanou paměť grafu se stará třída \texttt{Graf} a žádná jiná.


\section{Proměnné ve skriptu, typy a operace}

\subsection{Implementace operací větvením}

Existují v~zásadě dvě možnosti, jak implementovat sčítání, odčítání a ostatní operace nad hodnotami a proměnnými ve skriptu. Nejjednodušší z~nich předpokládá použití \texttt{unionu} a pomocné proměnné, která ukládá datový typ uložené hodnoty. Příkladem budiž ukázka z~autorova dřívějšího interpretu \cite[třída \texttt{CNodeValue}]{borsch}.

\begin{verbatim}
class CNodeValue
{
private:
    TYPE m_type;
    union
    {
        bool m_b;
        int m_i;
        float m_f;
    };
};
\end{verbatim}

Toto řešení je funkční, nicméně při více podporovaných datových typech a operacích začíná být extrémně nepřehledné a náchylné k~chybám. Každá z~funkcí implementujících například některou aritmetickou operaci musí obsahovat větvení podle typu, navíc, v~případě binární operace, vnořené.

\begin{verbatim}
const CNodeValue CNodeValue::operator+(const CNodeValue& object) const
{
    // ...

    switch(m_type)
    {
    case LEX_BOOL:
        switch(object.m_type)
        {
            case LEX_BOOL:  return CNodeValue(m_b + object.m_b);
            case LEX_INT:   return CNodeValue(m_b + object.m_i);
            case LEX_FLOAT: return CNodeValue(m_b + object.m_f);
            default: assert(false); return *this;
        }

        // ...
    }
}
\end{verbatim}

Výše uvedený kód ošetřuje sčítání boolean hodnoty s~boolean hodnotou, celým číslem a desetinným číslem. Jedná se pouze o~část funkce, v~případě tří různých datových typů by musela funkce obsahovat ještě další dvě ekvivalentní sekce, což přináší devět podmínek.

Navrhovaný jazyk předpokládá jedenáct různých datových typů (viz sekce \ref{datove_typy_a_promenne} na straně~\pageref{datove_typy_a_promenne}), což pouze pro sčítání dává celkem 121 větvení! Psát a poté udržovat podobný kód pro všechny operace je naprosto nereálné. Navíc přidání nového datového typu způsobí nutnost slo\-ži\-tých úprav všech existujících funkcí.


\subsection{Double dispatching pattern}
\label{double_dispatching_pattern}

Odpovědí na všechny výše uvedené problémy je návrhový vzor \textit{Multiple dispatching pattern} \cite[str. 679]{eckel}, který poskytuje možnost volání typových operací nad kombinací beztypových objektů. Základem je abstraktní třída \texttt{Value}, která deklaruje všechny potřebné operace -- pro každý datový typ a operaci jedna virtuální metoda, plus jedna čistě virtuální metoda pro neznámý datový typ.

\begin{verbatim}
class Value
{
    // +
    virtual CountPtr<Value> add(const Value&     right) const = 0;
    virtual CountPtr<Value> add(const ValueBool&  left) const;
    virtual CountPtr<Value> add(const ValueInt&   left) const;
    virtual CountPtr<Value> add(const ValueFloat& left) const;
    // ...
};
\end{verbatim}

Při sčítání celého čísla s~ostatními datovými typy je nejdříve nutné definovat sčítání celého čísla s~neznámým datovým typem na pravé straně. V~takovém případě funkce neví, jak tuto operaci provést, a proto požádá tento neznámý typ o~sečtení se sebou samým. Zároveň mu oznámí, že se jedná o~sčítání s~celým číslem, protože typ ukazatele \texttt{this} je zde \texttt{ValueInt*}.

\begin{verbatim}
CountPtr<Value> ValueInt::add(const Value& right) const
{
    return right.add(*this);
}
\end{verbatim}

Dejme tomu, že se jedná také o~celé číslo, zavolá se tedy následující metoda a provede sečtení celých čísel, jehož výsledkem je taktéž celé číslo. V~tuto chvíli jsou již všechny potřebné datové typy známy a operace se může vykonat.

\begin{verbatim}
CountPtr<Value> ValueInt::add(const ValueInt& left) const
{
    return CountPtr<Value>(new ValueInt(left.getVal() + m_val));
}
\end{verbatim}

Jednou z~výhod Double dispatching patternu je také to, že není nutné definovat všechny metody pro všechny kombinace datových typů. Pokud operace s~danými parametry nedává smysl, například sčítání čísla s~grafem, ponechá se vykonání operace na rodičovské třídě \texttt{Value}, jež může kupříkladu vypsat chybu a vrátit \texttt{null} hodnotu.

\begin{verbatim}
CountPtr<Value> Value::add(const ValueGraph& /* left */) const
{
    cerr << "Operation is not supported" << endl;
    return VALUENULL;
}
\end{verbatim}

V~případě přidání nového datového typu se žádná z~již existujících funkcí nemění, pouze se do základní třídy dopíše nová virtuální operace a do potomků, kde to dává smysl, její implementace.


\section{Reprezentace skriptu a vykonávání}

\subsection{Abstraktní strom syntaxe}
\label{abstraktni_strom_syntaxe}

Zdrojový soubor skriptu se překládá pomocí lexikálního analyzátoru a parseru do vnitřní reprezentace. Jejím základním prvkem je abstraktní třída \texttt{Node}, ze které jsou odvozeny všechny ostatní třídy, například třída pro větvení, třída pro cykly a další.

Posláním parseru je sestavit \textit{abstraktní strom syntaxe}, který se následně používá pro vykonávání programu. Povinností jednotlivých stavebních kamenů je definovat metodu \texttt{e\-xe\-cu\-te()}, jež se volá rekurzivně na všech úrovních stromu.

\begin{verbatim}
class Node
{
public:
    virtual CountPtr<Value> execute(void) = 0;
};
\end{verbatim}

Kontext skriptu (viz kapitola \ref{kontext_skriptu} na straně \pageref{kontext_skriptu}), ve kterém jsou uložené například hodnoty proměnných je vhodné definovat v~externí třídě, pravděpodobně singletonu. Druhou možností by bylo předávat kontext metodám v~parametru, ale to bylo v~současnosti označeno za zbytečné plýtvání výkonem, nepředpokládají se vícevláknové skripty.

Alternativní možností vykonávání skriptu by mohl být překlad do instrukcí virtuálního procesoru a jejich následná interpretace. To se však aktuálně jeví jako zbytečně náročné řešení, které nepřináší téměř nic navíc.


\subsection{Podpora krokování a debuggingu}
\label{podpora_debuggingu}

Výhodou lineárního pole instrukcí a virtuálního procesoru je snadná implementace de\-bug\-gin\-gu. V~kterémkoli okamžiku je možné pozastavit vykonávání, protože kód skriptu je včetně pozice uložen výhradně v~datové struktuře. Po případném opuštění interpretující funkce zůstane stav vir\-tu\-ál\-ní\-ho procesoru zachován a pozastavený skript může být kdykoli opětovně spuštěn.

Naproti tomu, při použití abstraktního stromu syntaxe je kód reprezentován především datovými typy uzlů a jejich strukturou. Vykonávání spočívá v~rekurzivním volání, kteréžto není možné přerušit a na stejném místě později obnovit. Vzniká otázka, jak pozastavit tato rekurzivní volání.

Odpovědí je \textit{vícevláknové programování} a jeho synchronizační prostředky. V~případě řádkové utility se debugging nepředpokládá, u~grafického rozhraní je další vlákno pro skript naopak nezbytné. Bez něj by aplikace po spuštění déletrvajícího skriptu nemohla reagovat na žádné požadavky a uživateli by se jevila jako zamrzlá.

Princip pozastavení skriptu demonstruje následující výpis kódu používající synchronizační prostředky knihovny Qt. Pokud skript narazí například na breakpoint, zavolá funkci \texttt{pause()}, jež ve \texttt{wait()} čeká na signál k~opětovnému spuštění. Tento příkaz vydává hlavní vlákno aplikace -- kupříkladu po kliknutí uživatele na tlačítko \textit{Pokračovat}.

\begin{verbatim}
QMutex dbgMutex;
QWaitCondition waitCondition;

// Script thread (e.g. breakpoint)
void pause(void)
{
    dbgMutex.lock();
    waitCondition.wait(&dbgMutex);
    dbgMutex.unlock();
}

// Main/GUI thread (e.g. click on next command button)
void resume(void)
{
    waitCondition.wakeAll();
}
\end{verbatim}

Ač se to nemusí zdát, je výše uvedené řešení plně funkční. Bylo implementováno v~jednoduché testovací aplikaci a pracuje bez jediného problému.


\subsection{Úniky paměti, správce paměti}

V~kapitole \ref{abstraktni_strom_syntaxe} na straně \pageref{abstraktni_strom_syntaxe} byla představena virtuální funkce \texttt{execute()}, jejíž rekurzivní volání umožňují interpretaci skriptu. Jednou ze zcela zásadních věcí je její návratová hodnota, která slouží především pro získání výsledku aritmetických výrazů.

Mějme například následující jednoduchý skript, jehož úkolem je sečíst dvě čísla.

\begin{verbatim}
function main(argv)
{
    return 1 + 2;
}
\end{verbatim}

Součet se v~syntaktickém stromu uloží celkem do tří uzlů. Listy vracejí svoji hodnotu ve formě celých čísel, binární operátor následně tyto dvě hodnoty sečte a vrátí výsledek operátoru \texttt{return}. Vykonávání pokračuje v~podobném duchu až do vynoření se z~kořene stromu. Celá situace je znázorněna ve schématu \ref{fig:execute}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=4cm]{img/execute.pdf}
\caption[Vyhodnocení příkazu]{Vyhodnocení příkazu "return 1 + 2;"}
\label{fig:execute}
\end{center}
\end{figure}

Je jasné, že třída pro sčítání nezná při kompilaci datový typ návratové hodnoty, může jím být například \texttt{null}, \texttt{int}, \texttt{float} aj., a tudíž návratovou hodnotou funkce musí být ukazatel na abstraktní objekt typu \texttt{Value} představený v~sekci \ref{double_dispatching_pattern} na straně \pageref{double_dispatching_pattern}.

Z~toho dále vyplývá, že se musí objekty vytvářet dynamicky, a s~tím bohužel souvisí velice častý problém programátorů v~jazycích C a C++: \textit{Kdy je možné tyto objekty smazat a která část kódu se o~to postará}.


\subsubsection{Garbage collector}

Jednou z~možností je používat \textit{Garbage collector} obdobný javovskému. Velkou výhodou by bylo vyřešení naprosto všech, současných i~budoucích, problémů s~u\-vol\-ňo\-vá\-ním dynamické paměti. Nevýhodou zůstává složitá implementace a dodatečná režie při vykonávání. V~případě použití nějakého již existujícího garbage collectoru vzniká závislost na externí knihovně a s~tím souvisí i~nižší či složitější přenositelnost programu.

V~tomto případě se zdá, že nevýhody převažují nad výhodami. Navíc se přece jedná o~ná\-vra\-to\-vou hodnotu \textit{výhradně} jedné funkce. Možná by stačilo zapouzdřit ukazatel na návratovou hodnotu do pomocné třídy, která by se postarala o~smazání ve chvíle, kdy už objekt není potřeba.


\subsubsection{Chytré ukazatele}
\label{chytre_ukazatele}

Nejjednodušší implementací chytrých ukazatelů je šablona \texttt{auto\_ptr} z~knihovny STL. Stačí nebo je potřeba nalézt silnější nástroj? \texttt{Auto\_ptr} se po požádání stává výhradním vlast\-ní\-kem ukazatele a při své destrukci maže i~předanou dynamickou paměť. \textit{Výhradní vlastník} znamená, že v~jednom okamžiku existuje vždy právě jedna \texttt{auto\_ptr} reference na danou paměť.

Splnit tento požadavek bohužel nelze. Chceme-li například vrátit hodnotu uloženou v~pro\-měn\-né interpretovaného skriptu, první referencí zůstane původní proměnná a druhá vznikne ve formě vracené hodnoty. Musíme tedy hledat silnější nástroj.

Pokud je jediným problémem \texttt{auto\_ptr} pouze možný větší počet odkazů, může se použít chytrý ukazatel na bázi čítání referencí \cite{smartp}. Ten zapouzdřuje ukazatel na dynamický objekt spolu s~čítačem, který se při vytvoření objektu nastaví na jedna a při každém zavolání kopírovacího konstruktoru nebo operátoru přiřazení inkrementuje. V~destruktoru se naopak počet referencí dekrementuje a při dosažení nulové hodnoty se objekt automaticky smaže.

Toto řešení by mohlo fungovat, je však nutné si dát pozor na cyklické reference, kdy první objekt odkazuje na druhý a zároveň druhý odkazuje na první, paměť by se nikdy neuvolnila. Zmíněná situace bohužel může nastat, protože právě tímto způsobem je uložena struktura grafu (viz kapitola \ref{reprezentace_mnozinami_vrcholu_a_hran} na straně \pageref{reprezentace_mnozinami_vrcholu_a_hran}). Vrcholy obsahují seznam incidujících hran a hrany odkaz na počáteční a koncový vrchol.

Z~toho plyne, že pokud se na tomto konkrétním místě chytrý ukazatel s~čítáním referencí nepoužije, nedojde ke vzniku cyklických referencí, a tudíž dostáváme řešení problému návratové hodnoty \texttt{execute()}.


\section{Grafické uživatelské rozhraní}

Grafické uživatelské rozhraní je naprogramováno s~použitím knihovny Qt. Sestává z~hlav\-ní\-ho okna aplikace \texttt{QMainWindow}, jehož centrálním widgetem je textový editor pro programátory na bázi \texttt{QPlainTextEdit}. Jedná se o~MDI aplikaci, jednotlivé editory je možné přepínat, po vzoru webových prohlížečů, pomocí panelů či listů. Menu, nástrojová lišta a stavový řádek jsou pro daný typ aplikace samozřejmostí.

Knihovna Qt poskytuje možnost vkládat do okrajů hlavního okna plovoucí panely, objekty třídy \texttt{QDockWidget}, jež mohou být přesunuty na jiné místo v~aplikaci a také \textit{vytrhnuty} do samostatného okna. Tato funkcionalita se určitě hodí u~vizualizací, v~případě jednoho monitoru je OpenGL widget panelem v~hlavním okně aplikace, zároveň však existuje možnost zobrazit ho i~v~samostatném okně například na druhém monitoru.

Panelů může být definováno libovolné množství, pro začátek se kromě vizualizací před\-po\-klá\-dá i~zobrazování výstupu z~vykonávaného skriptu, seznam definovaných proměnných spolu s~jejich hodnotami a zásobník volání funkcí.


\section{Shrnutí}

V~této kapitole byly definovány základní myšlenky a rozhodnutí pro tvorbu interpretu spe\-ci\-ál\-ní\-ho programovacího jazyka pro manipulaci s~grafy. Aplikace se naprogramuje v~jazyce C++ s~využitím standardní knihovny STL, grafická část v~Qt a OpenGL.

Analýza odhalila nemožnost reprezentovat graf maticí sousednosti ani jinými technikami, ve kterých je struktura grafu uložena centrálně. Navržené řešení spočívá v~obecných množinách vrcholů a hran, kde si vrcholy udržují seznam incidujících hran a hrany odkazy na svůj počáteční a koncový vrchol. Díky této technice může být podporován libovolný typ grafů bez jakéhokoli omezení a hlavně s~rozumnými složitostmi vykonávání všech operací.

Hodnoty a proměnné se ve skriptu implementují pomocí hierarchie tříd, jednotlivé operace pracují na bázi návrhového vzoru Double dispatching.

Skript je v~interpretu reprezentován abstraktním stromem syntaxe. Jeho vykonávání spočívá v~rekurzivním volání metody \texttt{execute()} nad každým uzlem tohoto stromu. Ná\-vra\-to\-vou hodnotou je chytrý ukazatel na bázi čítání referencí zapouzdřující obecnou hodnotu. Skript může být, v~případě debuggingu, pozastaven technikami ví\-ce\-vlák\-no\-vé\-ho programování.

Grafické uživatelské rozhraní zahrnuje hlavní okno s~textovým editorem pro programátory a několik speciálních plovoucích panelů, které mohou být uživatelem vytrhnuty do samostatného okna.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Realizace}

% Popis implementace / realizace se zaměřením na nestandardní části řešení.

\section{Základní kód a interpret pro příkazovou řádku}

\subsection{Lexikální analyzátor}

Jako základ pro lexikální analyzátor byl použit zdrojový kód z~předchozího autorova projektu \cite[třída \texttt{CLexan}]{borsch}. Jeho jádrem je rozsáhlý stavový automat, který zpracovává příchozí znaky a v~závislosti na nich vrací lexikální tokeny.

Analyzátor bere v~úvahu konstanty \texttt{\_\_FILE\_\_}, \texttt{\_\_LINE\_\_} a \texttt{\_\_FUNCTION\_\_}, které se při svém použití automaticky nahrazují za pozice ve zdrojových kódech. Dalšími vnitřními příkazy jsou jednoduchá bezparametrická makra \texttt{define("name", "value")} a vkládání externích souborů pomocí konstrukce \texttt{include("filename")}.

\subsubsection{Procházení zdrojových dat}

Makra i~soubory se v~principu zpracovávají naprosto stejně. Lexikální analyzátor obsahuje zásobník objektů typu \texttt{LexanIterator}, který slouží pro zanoření se do další úrovně ve zdrojových kódech skriptu. Například při inkluzi souboru se na vrcholu zásobníku vytvoří nová položka a při dokončení zpracování se odstraní. Překlad končí ve chvíli, kdy je zásobník vyprázdněn.

Abstraktní třída \texttt{LexanIterator} definuje rozhraní pro nejnižší vrstvu -- vlastní čtení znaků ze vstupního proudu. Jediný požadavek na potomky je specifikace metody \texttt{get()}, která má za úkol vrátit následující znak v~pořadí a \texttt{unget()} sloužící pro návrat o~znak zpátky. Třída dále ukládá pozici ve zdrojových kódech používanou především v~chybových zprávách.

Aktuálně jsou definováni pouze dva potomci. \texttt{LexanIteratorFile} má za úkol iterovat přes znaky v~souboru, používá ho konstrukce \texttt{include}. Řetězce, nebo-li \texttt{define} makra, se zpracovávají třídou \texttt{Le\-xan\-Ite\-ra\-tor\-String}. V~budoucnu je možné, bez větších zásahů do aplikace, přidat další zdroje kódu, například soubory nahrávané z~internetu.


\subsubsection{Identifikátory}
\label{identifikatory}

Řetězce ve skriptu, jména proměnných a funkcí, se během lexikální analýzy nahrazují za celočíselné identifikátory, stejnou myšlenku používá i~interpret JavaScriptu ve webovém pro\-hlí\-že\-či Links \cite[str. 25]{links}.

Ve chvíli, kdy lexikální analyzátor narazí ve zdrojovém proudu na shluk znaků, který by mohl být identifikátorem, zkontroluje nejdříve, zda se nejedná o~klíčové slovo. V~případě negativního výsledku projde seznam skriptem definovaných maker a pokusí se je rozbalit. Neuspěje-li ani zde, použije makro \texttt{STR2ID()}, které požádá tabulku symbolů, třídu \texttt{StringTable}, o~překlad řetězce na celočíselný identifikátor. Opačný směr umožňuje makro \texttt{ID2STR()}.

Algoritmus překladu je velice jednoduchý. Tabulka symbolů je tvořena obyčejným polem, jehož jednotlivé položky ukládají řetězcovou reprezentaci, hodnota indexu představuje reprezentaci číselnou. Při žádosti o~překlad z~řetězce na identifikátor zkusí třída najít a vrátit pozici již existujícího prvku. Pokud neuspěje, přidá řetězec na konec pole a vrátí jeho pozici.

Asymptotická složitost operace vychází v~nejhorším případě lineární, protože se musí při prvním výskytu řetězce projít kompletně všechny dříve definované prvky. Její snížení, na\-pří\-klad seřazením položek podle abecedy, není možné, pořadí v~poli se nesmí změnit, protože by se zneplatnily již existující překlady. Opačný směr představuje operaci s~konstantní složitostí, identifikátor je současně indexem do pole.

\begin{verbatim}
identifier StringTable::getID(const string& str)
{
    vector<string>::iterator pos = find(m_data.begin(), m_data.end(), str);

    if(pos == m_data.end())
        m_data.push_back(str);

    return pos - m_data.begin();
}

string& StringTable::getString(identifier id)
{
    return m_data[id];
}
\end{verbatim}

Hlavní výhodou této techniky je vyšší rychlost interpretace, porovnání dvou čísel trvá mnohem kratší dobu než porovnání dvou řetězců. Úspora vzniká při každém přístupu k~hodnotě proměnné a při volání funkcí. Druhá z~výhod spočívá ve snížených paměťových nárocích, všechny řetězce jsou uloženy bez duplicit na jednom místě a ve skriptu je reprezentují pouze celočíselné hodnoty. Jak už bylo zmíněno, jediné zpomalení nastává při vytváření tabulky symbolů, je přímo úměrné počtu různých identifikátorů ve zdrojovém textu a jejich délce.


\subsection{Gramatika, parser}

Gramatiku vytvořeného jazyka je možné najít v~příloze \ref{gramatika_jazyka} na straně \pageref{gramatika_jazyka}, alternativně ve zdrojovém souboru \texttt{parser.y}. Jedná se o~standardní vstupní kód pro generátor gramatik GNU Bison, který má za úkol vystavět abstraktní strom syntaxe. Při vytváření se vycházelo z~předpisu pro jazyk Ansi~C~\cite{c_grammar}.


\subsection{Hierarchie tříd, základní třída BaseObject}

V~objektově orientovaném návrhu aplikačního rozhraní je vždy dobré zavést kořen hierarchie tříd, který poskytuje, či pouze definuje, základní obecné operace nad všemi používanými objekty. V~jazyce Java se taková třída jmenuje \texttt{Object}, knihovna Qt zavádí \texttt{QObject}, \texttt{CObject} je k~nalezení v~knihovně MFC. Vyvíjená aplikace použije jméno \texttt{Ba\-se\-Ob\-ject}.


\subsubsection{Výpis struktury objektů, metoda dump()}

\texttt{BaseObject} v~první řadě definuje čistě virtuální metodu \texttt{dump()}, díky níž je možné vypsat obsah daného objektu. Využití je předpokládáno především při stavbě a ověřování abstraktního stromu syntaxe, metoda umožňuje jeho přehledný výpis.

Pokud každá odvozená třída definuje svoji metodu \texttt{dump()} -- a ona ji definovat musí, protože je čistě virtuální -- může do předaného proudu vypsat informace o~sobě a o~objektech, které v~sobě uchovává. Mějme na\-pří\-klad jednoduchý demonstrační skript.

\begin{verbatim}
function main(argv)
{
    value = 1 + 2 * 3;
}
\end{verbatim}

Po přeložení kódu do vnitřní reprezentace a zavolání \texttt{dump()} vypadá vypsaná struktura objektů následovně.

\begin{verbatim}
<Function name="main" id="63">
    <Parameter name="argv" id="64" />
    <NodeBinaryAss>
        <ValueIdentifier name="value" id="65">
            <NoValue />
        </ValueIdentifier>
        <NodeBinaryAdd>
            <ValueInt value="1" />
            <NodeBinaryMult>
                <ValueInt value="2" />
                <ValueInt value="3" />
            </NodeBinaryMult>
        </NodeBinaryAdd>
    </NodeBinaryAss>
</Function>
\end{verbatim}

XML formát výstupu samozřejmě není nutný, byl použit pouze kvůli přehlednosti výpisu strukturovaných dat.


\subsubsection{Kontrola úniků paměti}
\label{kontrola_uniku_pameti}

Druhou funkcionalitou poskytovanou základní třídou \texttt{BaseObject} jsou testy na úniky dynamické paměti. Jedná se pouze o~rychlé ověření, zda změny provedené při vývoji nezpůsobily nějaký nečekaný problém, a proto záměrně není ani implementace nijak složitá.

Třída definuje statické úložiště adres alokovaných objektů. Při své konstrukci do něj vloží ukazatel na právě vytvořený objekt, v~destruktoru ho smaže, toť vše. Jelikož se jedná o~kořen hierarchie tříd, tento konstruktor a destruktor se z~definice volá u~naprosto všech vytvářených objektů.

Těsně před ukončením funkce \texttt{main()} se zjistí aktuální počet alokovaných dat. Pokud není nulový, je jasné, že se někde v~aplikaci objevil únik paměti a tato skutečnost je signalizována vývojáři. Díky RTTI, které jazyk C++ podporuje operátorem \texttt{typeid}, je možné získat i~datový typ neuvolněných objektů.

Kód pro testy může způsobovat výrazné zpomalení běhu aplikace, a proto byl obalen do podmíněné sekce preprocesoru \texttt{CHECK\_MEMORY\_LEAKS}, jež je zapnutá pouze při \textit{debug} kompilaci. Ve výsledné verzi samozřejmě nejsou tyto testy potřeba a ve spustitelném souboru se ani fyzicky nenacházejí.

Pozorný čtenář si pravděpodobně uvědomil, že nejsou kontrolovány pouze dynamické, ale i~statické alokace. Možná by stálo za úvahu vložit kód do přetížených operátorů \texttt{new} a \texttt{delete}, nicméně statické objekty jsou uvolněny vždy, a proto nemají žádný vliv na správnost zjištěné informace.

Dále se nekontrolují alokace paměti, která nepatří do \texttt{BaseObject} hierarchie, ty se však v~kódu vyskytují spíše zřídka. Pro zjištění jejich úniků slouží, taktéž používaný, nástroj Valgrind (\url{http://www.valgrind.org/}).


\subsubsection{Pořadí inicializace statických objektů}

Učebnice jazyka C++ se pouze velice zřídka věnují tématu \textit{pořadí inicializace statických objektů} (angl. static object initialization order), jednou z~mála výjimek je \cite{industrial_strength_cpp}. Jedná se o~situaci, kdy linker při spojování jednotlivých modulů může způsobit zásadní nefunkčnost naprosto správného kódu!

Termín \textit{statický objekt} je zde používán ve významu atributu třídy deklarovaného s~modifikátorem \texttt{static}, jenž způsobuje sdílení mezi odpovídajícími objekty. Jako praktickou ukázku nastavší chyby můžeme použít statickou proměnnou \texttt{m\_allocated\_objects} třídy \texttt{BaseObject} z~kapitoly \ref{kontrola_uniku_pameti} na straně \pageref{kontrola_uniku_pameti}.

Statický objekt je vytvářen a inicializován ještě před vlastním spuštěním funkce \texttt{main()}, jazyk C++ pro instanciaci a inicializaci používá speciální konstrukci zapsanou vně všech funkcí a tříd.

\begin{verbatim}
class BaseObject
{
    static set<BaseObject*> m_allocated_objects;
};
set<BaseObject*> BaseObject::m_allocated_objects;
\end{verbatim}

Definujme ještě jednu třídu, singleton poděděný od \texttt{BaseObject}, jenž v~sobě obsahuje taktéž statický objekt.

\begin{verbatim}
class Singleton : public BaseObject
{
    static Singleton m_instance;
};
Singleton Singleton::m_instance;
\end{verbatim}

Inicializuje vygenerovaný kód \texttt{m\_allocated\_objects} dříve než proměnnou \texttt{m\_in\-stan\-ce}, či naopak? Jedná se o~zásadní otázku, protože \texttt{Singleton} dědí od \texttt{BaseObject}, a tudíž pracuje s~proměnnou \texttt{m\_allocated\_objects}, která však v~tuto chvíli ještě nemusí existovat. Vše tedy závisí na linkeru, nevhodné pořadí spojení modulů může způsobit neoprávněný přístup do paměti a následný pád aplikace ještě před vlastním spuštěním funkce \texttt{main()}.

Pokud nejde použití statických objektů v~aplikaci zamezit nebo je jiné řešení silně nepraktické, existuje proti chybě relativně snadná obrana. Stačí založit nový soubor se zdrojovými kódy a přesunout do něj všechny problematické inicializace.

Jazyk C++ garantuje pořadí inicializací v~rámci jednotlivých modulů. Nahoru je tedy třeba zapsat ty, jež se mají provést nejdříve, a dolů ty, které na nich závisí. Obsah souboru by tedy vypadal následovně.

\begin{verbatim}
set<BaseObject*> BaseObject::m_allocated_objects;
Singleton Singleton::m_instance;
\end{verbatim}

Vyvíjená aplikace nakonec používá zcela jiné řešení. Statické nejsou samotné objekty (singletony), ale pouze ukazatele na ně, inicializace na \texttt{NULL} vždy proběhne bezchybně. O~vytvoření a smazání vlastních objektů se stará kód na začátku a konci funkce \texttt{main()}, který může explicitně ovlivnit pořadí.

Další možností by mohlo být nastavení priorit modulů při linkování, například u~Makefile/gcc se jedná pouze o~pořadí zápisu na příkazové řádce. Problémy spojené s~tímto řešením nejspíše vyvstanou až někdy v~budoucnu.

Už bylo řečeno, že chyba není fyzicky přítomná v~kódu, a tudíž se na ni při libovolné změně může snadno zapomenout. Typicky se jedná o~přidání nového souboru, či o~aktualizaci nebo změnu buildovacího systému. Používaná vývojová prostředí, současná i~budoucí, tato nastavení také nemusí vůbec podporovat, a proto je lepší vzít v~úvahu spíše řešení spočívající ve změně zdrojových kódů.

Je pravda, že výše uvedená ukázka je k~chybě výrazně náchylnější než běžná použití statických objektů. Na druhou stranu, autor se již dříve, při portaci legacy aplikací na nový operační systém, setkal s~obdobným problémem. V~obou případech se navíc jedná o~dva různé kompilátory -- Microsoft Visual Studio 2003/2005 oproti GNU gcc.


\subsection{Hodnoty a proměnné ve skriptu, Value* hierarchie tříd}

Jak už bylo zmíněno v~kapitole \ref{double_dispatching_pattern} analýzy na straně \pageref{double_dispatching_pattern}, binární operace nad hodnotami ve skriptu jsou vykonávány s~využitím návrhového vzoru Double dispatching. Kořenem hierarchie je abstraktní třída \texttt{Value}, potomci se jmenují \texttt{ValueNull}, \texttt{Va\-lue\-Bool}, \texttt{ValueInt}, \texttt{ValueFloat} atd., class diagram této skupiny tříd je uveden na obrázku \ref{fig:value_hierarchy}.

\begin{figure}[ht]
\begin{center}
\includegraphics[height=12cm]{img/classValue__inherit__graph.pdf}
\caption{Hierarchie Value* tříd}
\label{fig:value_hierarchy}
\end{center}
\end{figure}

Iterování přes prvky složených datových typů je podporováno čtyřmi, taktéž virtuálními, metodami \texttt{iterator()}, \texttt{hasNext()}, \texttt{next()} a \texttt{resetIterator()}. Jednoduché datové typy nejsou iterovatelné, a proto jakékoli pokusy o~procházení hned na začátku odmítnou.

Potomci, především grafové třídy, definují i~další metody, není reálné, aby všechny operace, včetně silně specifických, byly virtuální. Ke konverzi z~obecného \texttt{Value} ukazatele na konkrétní datový typ slouží skupina virtuálních funkcí \texttt{toValueBool()}, \texttt{toValueInt()} atd., které vracejí \texttt{NULL}, pokud se nejedná o~daný datový typ. Na tomto místě by šlo samozřejmě použít i~RTTI přetypování \texttt{dynamic\_cast<>}, obě techniky jsou ekvivalentní. Použití leží především v~zabudovaných funkcích interpretu, které v~parametrech předpokládají konkrétní datové typy a volají jejich specifické operace.


\subsubsection{ValueNull a ValueBool}

Obě tyto třídy jsou definovány jako singleton a v~kódu mohou být používány pomocí zkrá\-ce\-né\-ho zápisu \texttt{VALUENULL}, \texttt{VALUEBOOL\_TRUE} a \texttt{VALUEBOOL\_FALSE}. Jedná se o~makra, která volají statické metody \texttt{getInstance()}.

Implementace pomocí singletonu byla zvolena z~důvodu, aby nebylo nutné neustále vytvářet nové a nové ekvivalentní objekty.


\subsubsection{Přiřazování do proměnných}
\label{valuereference_a_prirazovani_do_promennych}

K~dotazu, zda je možné do nějakého \texttt{Value} objektu přiřadit jinou hodnotu, slouží metoda \texttt{isLValue()}. Vlastní přiřazení je následně možné provést funkcí \texttt{assign()} nebo \texttt{assignRef()} v~případě přiřazování reference.

Proměnné jsou ve skriptu reprezentovány třídou \texttt{ValueIdentifier}, která v~sobě u\-cho\-vá\-vá identifikátor hodnoty odkazující do kontextu skriptu. Všechny operace se vykonávají stejně jako u~ostatních tříd, rozdíl spočívá pouze v~tom, že se neprovádějí přímo s~daným objektem, ale s~odkazovaným.

Jelikož je navržený jazyk beztypový, proměnné musejí umět měnit nejen svou hodnotu, ale i~datový typ, jedná se tedy o~složitější operaci, než je například pouhá záměna jednoho čísla za jiné. Interpret tuto situaci řeší obalením vlastní hodnoty další třídou pojmenovanou \texttt{ValueReference}, přiřazení poté probíhá podle následujícího schématu:

\begin{enumerate}
\item Operátor přiřazení vyhodnotí výraz na své levé straně:
	\begin{itemize}
	\item Proměnná požádá kontext o~nalezení hodnoty uložené pod daným jménem.
	\item Pole poskytne prvek na daném indexu.
	\item Struktura najde prvek specifikovaného jména.
	\item Kombinace předchozích možností (např. \texttt{objects[2].position.x}).
	\end{itemize}
\item Výsledkem je vždy nějaká hodnota obalená ve třídě \texttt{ValueReference}.
\item Operátor přiřazení vyhodnotí výraz na své pravé straně.
\item \texttt{ValueReference} je požádáno o~záměnu obalené hodnoty za novou.
\end{enumerate}

V~případě, že proměnná daného jména, popř. položka struktury, ještě neexistuje, nově vytvořená \texttt{ValueReference} obaluje \texttt{ValueNull} hodnotu. Pole se při přístupu za své hranice automaticky nezvětšuje, je vypsána chyba.


\subsubsection{Grafové třídy}

Všechny grafové třídy jsou, stejně jako ostatní hodnoty, potomky abstraktní třídy \texttt{Value}, a tudíž musí i~ony implementovat Double dispatching metody vyhodnocování operátorů. Třída \texttt{ValueGraph} reprezentuje graf na principu množin vrcholů a hran, který byl představen v~kapitole \ref{reprezentace_mnozinami_vrcholu_a_hran} na straně \pageref{reprezentace_mnozinami_vrcholu_a_hran}.

Pro ukládání vrcholů a hran se nepoužívá původně preferovaná standardní šablona \texttt{set}, ale vlastní třída \texttt{ValueSet}, která zobecňuje práci s~těmito množinami a současně zpřístupňuje interpretu i~nový datový typ. Toto řešení vychází především z~problémů s~\textit{dangling} ukazateli v~případě, kdy jsou veškerá data grafu uvolněna, ale z~interpretu stále existují odkazy na vrcholy a hrany -- například reference v~proměnné nebo v~některé z~množin.

K~řešení se opět využívá principu čítání ukazatelů. Aby nedocházelo ke dříve zmíněným kruhovým závislostem mezi vrcholy a hranami (kapitola \ref{chytre_ukazatele} na straně \pageref{chytre_ukazatele}), musí hrany ukládat pouze obyčejné ukazatele na počáteční a koncový vrchol a vždy testovat jejich platnost.

Graf může být vytvořen ručně opakovaným voláním funkcí \texttt{generateVertex()} a \texttt{ge\-ne\-ra\-te\-Ed\-ge()}, či automaticky z~datového souboru funkcí \texttt{lo\-ad\-From\-Fi\-le()}. Formát souborů je specifikován v~příloze \ref{format_datovych_souboru_s_grafem} na straně \pageref{format_datovych_souboru_s_grafem}.

Vykonávané operace rozlišují, zda je graf orientovaný či ne, orientace hran může být také kdykoli invertována. Matice sousednosti není přímo přístupná, protože se s~ní vnitřně nepočítá, ale může být na žádost \texttt{getAdjacencyMatrix()} vygenerována a vrácena.

Třídy \texttt{ValueVertex} i~\texttt{ValueEdge} v~sobě obsahují \texttt{ValueStruct} atribut a mapují na něj všechny nedostupné operace, aby jejich rozhraní bylo ekvivalentní -- jedná se o~variaci na návrhový vzor \textit{Proxy}. Skládání dostalo přednost před dědičností, protože vrchol ani hrana \textit{nejsou} ve své podstatě strukturou. Návrh funkcionality je pouze takový, že poskytují stejné služby, ale to není dostatečným důvodem pro dědičnost.

Poslání množin vrcholů a hran reprezentovaných třídou \texttt{ValueSet} je především udržovat záznamy o~registrovaných objektech. Kromě toho se navíc mohou iterovat a je s~nimi možné vykonávat operace průniku, sjednocení či rozdílu. \texttt{ValueSet} neslouží výhradně pro vrcholy a hrany, ale pro libovolný typ \texttt{Value} objektů.


\subsection{Abstraktní strom syntaxe, Node* hierarchie tříd}

Abstraktní třída \texttt{Node} byla již představena v~analýze, v~kapitole \ref{abstraktni_strom_syntaxe} na straně \pageref{abstraktni_strom_syntaxe}. Z~ní vycházejí všechny ostatní třídy, jejichž objekty ve výsledku vytvářejí strukturu abstraktního stromu syntaxe. Hierarchie tříd je k~nalezení v~příloze~\ref{hierarchie_trid} na straně~\pageref{hierarchie_trid}.

Unární operátory jsou potomky třídy \texttt{NodeUnary}, která předpokládá jednoho následníka ve stromě, \texttt{NodeBinary} logicky dva. Ternální operátor je interně mapován na \texttt{if-else} větvení poskytované třídou \texttt{NodeCondition}. Dalšími podtřídami jsou například \texttt{Node\-Loop} a \texttt{No\-de\-For\-each} cykly, \texttt{NodeBlock} zapouzdřuje skupinu příkazů, \texttt{Node\-Function\-Call} slouží pro volání funkcí. Prázdný příkaz \texttt{NodeEmptyCommand} se využívá spíše interně.

Třída \texttt{NodeValue} definuje spojnici mezi \texttt{Node} a \texttt{Value} hierarchiemi, \texttt{NodeGlobal} poskytuje propagaci globálních proměnných do lokálního kontextu funkce. \texttt{NodePosition} slouží pro aktualizaci pozice odkazující do zdrojových kódů skriptu.


\subsubsection{Strukturované skoky}
\label{strukturovane_skoky}

Strukturované skoky \texttt{break}, \texttt{continue} a \texttt{return} používají mechanismus výjimek, což je jedna z~mála výraznějších daní za jednoduchost vykonávání skriptu pomocí rekurzivního volání metody \texttt{execute()}. Příkaz skoku, byť strukturovaný, musí být nějakým způsobem schopen opustit zanořené volání a vystoupat do požadovaného místa. Výjimky jsou zde opravdu tou nejelegantnější cestou.

Místo, kde se má skok zastavit, je definováno strukturou objektů ve stromu. Například výše uvedený příkaz \texttt{break} by se měl zastavit za koncem nejzanořenějšího cyklu. V~případě \texttt{continue} se samozřejmě jedná o~návrat na začátek před další iteraci. Přesně podle této definice funguje uzel \texttt{NodeLoop}, výjimka typu \texttt{NodeJumpBreak} je zachytávána za vlastním tělem cyklu, \texttt{NodeJumpContinue} uvnitř.

\begin{verbatim}
CountPtr<Value> NodeLoop::execute(void)
{
    m_init->execute();

    try
    {
        while(m_condition->execute()->toBool())
        {
            try
            {
                m_body->execute();
            }
            catch(NodeJumpContinue* ex) { }

            m_inc->execute();
        }
    }
    catch(NodeJumpBreak* ex) { }
}
\end{verbatim}

Protože volání cyklů probíhá od vnějších k~vnitřním, je případná výjimka vždy zachycena v~nejvnitřnějším možném cyklu. Výkonnostní poměry u~těchto typů konstrukcí příliš neutrpí, \texttt{break} a \texttt{continue} se v~reálných programech vyskytují spíše zřídka.

U~návratových hodnot funkcí je situace opačná, \texttt{return} se vyskytuje téměř v~každé. Ano, zde jsou výjimky bolestné, nicméně, z~druhé strany pohledu, ne tak moc jako implementace bez jejich služeb.

Příkaz \texttt{return} by mohl nastavit hodnotu sdílené proměnné v~kontextu na výstupní hodnotu z~funkce a zároveň v~další proměnné signalizovat, že probíhá návrat z~funkce. Metoda \texttt{execute()} by u~naprosto všech tříd musela testovat tuto signalizační proměnnou, a v~době mezi \texttt{return} až do ukončení těla funkce by se nezanořovala do dalších příkazů. Obrovské množství těchto větvení by jistě přesáhlo režii jedné nastavší výjimky.


\subsubsection{Funkce}

Funkce, potomci třídy \texttt{NodeFunction}, se dělí na dvě skupiny -- na zapsané ve skriptu a na zabudované do interpretu. Každou z~nich identifikuje jméno a parametry, při volání se ovšem používá pouze jméno. První typ při inicializaci očekává tělo s~příkazy a pozici ve zdrojových kódech, kde je definována. U~zabudovaných funkcí, potomků \texttt{Node\-Function\-Builtin}, tyto informace nemají význam, tělo je specifikováno přímo C++ kódem metody \texttt{execute()}.

Funkci umí zavolat třída \texttt{NodeFunctionCall}. Ta se ji nejdříve pokusí najít pomocí uloženého jména a zkontroluje počty deklarovaných a předaných parametrů. Pokud vše souhlasí, vyhodnotí parametry, vloží na zásobník volání novou položku, podle specifikovaných jmen parametrů definuje požadované proměnné a spustí tělo funkce.


\subsection{Kontext skriptu}
\label{kontext_skriptu}

V~textu byl již několikrát zmíněn, do této chvíle bez dostatečného vysvětlení, termín \textit{kontext skriptu}. V~kódu se jedná o~jednu z~funkcionálně nejbohatších tříd aplikace pojmenovanou \texttt{Context}. Tato třída mimo jiné ukládá zabudované i~uživatelské funkce, globální proměnné a zásobník volání funkcí spolu s~lokálními proměnnými. Dále si vede záznam o~aktuální pozici ve zdrojových kódech, který slouží především při vypisování chybových zpráv, a také umí pomocí databáze řetězců převádět jména identifikátorů skriptu z~řetězcové do číselné formy a naopak (viz kapitola \ref{identifikatory} na straně \pageref{identifikatory}).


\subsubsection{Funkce ve skriptu, jejich volání a spuštění skriptu}

Všechny definované a tudíž i~volatelné funkce se ukládají do asociativního pole indexovaného číselným identifikátorem, datová položka se skládá z~ukazatele na abstraktní nadtřídu \texttt{NodeFunction}. Kontext nepotřebuje znát, o~který z~obou typů funkcí se jedná, samotné objekty to vědí a díky polymorfismu se při spuštění volají odpovídající metody. Hledání pouze podle jména znemožňuje přetěžování funkcí, k~jeho zprovoznění by bylo potřeba ukládat dodatečné informace, na\-pří\-klad počet argumentů, a používat je i~při vyhledávání.

Zásobník volání je taktéž uložen v~kontextu skriptu. Jedná se o~pole objektů typu \texttt{Call\-Stack\-Item}, jež v~sobě ukládají jméno právě spuštěné funkce, pozici v~kódu, odkud byla zavolána, a hodnoty lokálních proměnných na dané úrovni.

Vlastní spuštění funkce je úkolem třídy \texttt{NodeFunctionCall}. Objekty tohoto datového typu si v~sobě uchovávají identifikátor volané funkce, kód nutný pro zjištění hodnot parametrů a pozici v~kódu, odkud je funkce volána. Celý životní cyklus funkce vypadá následovně:

\begin{enumerate}
\item V~kontextu je podle jména nalezen objekt \texttt{NodeFunction*}.
\item Ověří se počet deklarovaných a předaných parametrů.
\item Vyhodnotí se kód nutný pro získání hodnot parametrů.
\item Na vrchol zásobníku volání je přidána nově vytvořená položka.
\item Nastaví se hodnoty argumentů (lokální proměnné) na hodnoty předané v~parametrech.
\item Zavolá se \texttt{execute()} metoda objektu funkce.
\item Vykonají se všechny příkazy obsažené v~těle funkce.
\item Po skončení se z~vrcholu zásobníku volání odstraní dříve přidaná položka.
\item Vrátí se návratová hodnota.
\end{enumerate}

Již bylo řečeno, že skript se spouští voláním funkce \texttt{main(argv)}. Tuto operaci opět poskytuje kontext, konkrétně se jedná o~metodu \texttt{executeScriptMain()}, jež vytvoří objekt typu \texttt{NodeFunctionCall}, do konstruktoru mu předá identifikátor \textit{main} a \texttt{ValueArray} parametr. Následně je odstartováno rekurzivní volání \texttt{execute()} metod nad uzly abstraktního stromu syntaxe.


\subsubsection{Globální proměnné}

Seznam lokálních i~globálních proměnných je stejně jako kontejner definovaných funkcí reprezentován asociativním polem. Kontext neposkytuje žádné metody pro získání nebo nastavení hodnoty globální proměnné. Naproti tomu umožňuje funkcí \texttt{propagateGlobalVariable()} namapovat její hodnotu do adresního prostoru právě zavolané lokální funkce, což ve skriptu přesně odpovídá chování operátoru \texttt{global} představeného v~kapitole \ref{datove_typy_a_promenne} na straně \pageref{datove_typy_a_promenne}.

Celý mechanismus funguje na principu sdílení \texttt{ValueReference} objektu mezi globálními a lo\-kál\-ní\-mi proměnnými. Změní-li se hodnota lokální proměnné, která odkazuje na stejný objekt jako globální proměnná, je automaticky aktualizována i~ta, protože sídlí na stejném místě v~paměti.


\subsubsection{Pozice v~kódu}
\label{pozice_v_kodu}

Je jasné, že není potřeba, aby byla pozice ve zdrojových kódech reprezentovaná třídou \texttt{CodePosition} přítomna v~naprosto každém z~uzlů stromu syntaxe. Dokud by se nezměnilo jméno vstupního souboru ani číslo řádky, docházelo by pouze k~paměťově náročným duplikacím, které by při vykonávání nepřinášely žádnou novou informaci.

Bylo by žádoucí, aby každá řádka vstupního souboru měla svou uzlovou reprezentaci ve stromu, avšak syntaktický analyzátor v~dané implementaci nepracuje po řádcích, ale po tokenech. Pokud se berou v~úvahu \textit{příkazy} namísto řádků, je možné se k~tomuto požadavku přiblížit. Téměř každý příkaz (výraz zakončený středníkem) bývá uveden na samostatné řádce, v~některých méně častých případech i~na dvou či třech. To ale nevadí, pozice v~chybových hlášeních mají pouze o~něco menší přesnost, stále však naprosto dostatečnou.

Místa ve zdrojových kódech jsou tedy uchovávány pouze ve speciálních uzlech stromu, příkazy se obalují objekty typu \texttt{NodePosition}, jejichž prací je aktualizovat pozici v~kontextu a zavolat metodu svého ná\-sled\-ní\-ka ve stromu.

Oba způsoby ukládání pozic v~jednoduchém demonstračním příkazu \texttt{c = a + b;} jsou zobrazeny ve schématu \ref{fig:nodeposition}. Třída \texttt{NodeBinaryAdd} odpovídá sčítání a \texttt{NodeBinaryAss} přiřazení. Na první pohled je jasné, že ukládání pozic do každého uzlu stromu by bylo zbytečné a navíc by docházelo ke značnému plýtvání pamětí.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=12cm]{img/nodeposition.pdf}
\caption{Dva možné přístupy k~ukládání pozic v~abstraktním stromu syntaxe}
\label{fig:nodeposition}
\end{center}
\end{figure}

Třída \texttt{NodePosition} v~sobě zapouzdřuje objekt typu \texttt{CodePosition}, jenž je jednoduchým kontejnerem uchovávajícím jméno souboru a číslo řádky. Jméno souboru opět není ukládáno v~řetězcové formě, ale jako číselné ID, což přispívá k~dalšímu šetření paměti.

Kontext skriptu obsahuje datovou \texttt{CodePosition} položku, jež je během průchodu abs\-trakt\-ním stromem syntaxe s~pomocí \texttt{NodePosition} uzlů a volání \texttt{setPosition()} průběžně aktualizována a může být použita například při výpisu chybové zprávy.


\subsubsection{Paralelizace skriptů, více kontextů}

Kontext skriptu je ostatními třídami používán téměř jako singleton, přistupují k~němu pomocí makra \texttt{CONTEXT}, které se rozbaluje na volání \texttt{getContext()} třídy \texttt{ObjectCreator}. V~průběhu vykonávání skriptu existuje vždy právě jeden kontext, a tudíž není paralelní běh na úrovni skriptu aktuálně podporován.

Pokud by vznikla potřeba vícevláknového programování, existuje v~zásadě pouze jediná mož\-nost, jak doprogramovat jeho podporu. Spočívá v~dodatečném argumentu \texttt{execute()} metod, který si uzly stromu předávají při rekurzivním vykonávání. Nevýhody jsou zřejmé, naprostá většina uzlů kontext ke své činnosti nepotřebuje, a tudíž by jeho neustálé kopírování, byť i~ve formě reference, zpomalovalo běh skriptu.


\subsection{Logování, textový výstup}

Výpis textového výstupu ze skriptu, varovných, chybových a ladících zpráv kompletně za\-jiš\-ťu\-je třída \texttt{Logger}. Aplikace definuje několik maker, například \texttt{ERR()}, \texttt{WARN()} nebo \texttt{INFO()}, které slouží jako aplikační rozhraní pro výpis zpráv uživateli.

Přímý přístup k~vstupně/výstupním proudům jazyka C++ není používán, aby bylo jednodušší přesměrovat veškerý výstup skriptu do některého z~oken aplikace při běhu v~grafickém rozhraní. Tomuto tématu se více věnuje kapitola \ref{oddeleni_od_interpretu_pro_prikazovou_radku} na straně \pageref{oddeleni_od_interpretu_pro_prikazovou_radku}.


\subsection{Generátory zdrojových kódů}

Interpret obsahuje několik skupin tříd, jejichž kód je velice podobný, typickým příkladem jsou třídy aritmetických a logických operátorů. Vezměme si třeba operátory pro sčítání a odčítání, jejich výkonná část se liší jediným příkazem. Sčítání volá metodu \texttt{add()} a odčítání \texttt{sub()}, jinak je celý kód identický.

\begin{verbatim}
return m_left->execute()->add(*(m_right->execute()));
return m_left->execute()->sub(*(m_right->execute()));
\end{verbatim}

Kromě těchto dvou je potřeba dalších dvacet binárních operátorů, k~tomu několik unárních operátorů a nesmí se zapomenout ani na zabudované funkce. Vytvářet všechny třídy ručně je zdlouhavé a neefektivní, v~případě změn je třeba manuálně upravovat stejným způsobem spoustu souborů.

Nepříliš vhodné řešení této situace je využití C++ maker, jimiž lze generovat libovolný kód, tedy i~třídy. Jedna z~primitivnějších a ne moc hezkých implementací by mohla vypadat například následovně.

\begin{verbatim}
#define UNARYOPERATOR(NAME, CODE)             \
class NAME : public NodeUnary                 \
{                                             \
public:                                       \
    NAME(Node* next) : NodeUnary(next) { }    \
                                              \
    virtual CountPtr<Value> execute(void)     \
    {                                         \
        CODE                                  \
    }                                         \
};

UNARYOPERATOR(NodeUnarySub, return m_next->execute()->subUn();)
UNARYOPERATOR(NodeUnaryNot, return m_next->execute()->logNOT();)
\end{verbatim}

Jedná se o~plně funkční kód v~profesionální praxi běžně používaný, ale obecně hodně špatný a naprosto nevhodný pro libovolnou situaci. Kvůli těmto konstrukcím především není možné ladění programu. Při psaní také nefunguje automatické do\-pl\-ňo\-vá\-ní kódu, protože s~podobným zápisem tvůrci žádného IDE zkrátka nepočítali. Počáteční úsporu času a zrychlení vývoje velice rychle, při prvních problémech a neúspěšných pokusech o~ladění, vystřídají myšlenky na kompletní přepsání ručním rozbalením maker.

Řešením situace je sáhnout po externím skriptu, jehož jediným posláním je podle při\-pra\-ve\-né šablony generovat C++ soubory s~definicí jednotlivých tříd. Pokud vznikne požadavek na úpravu, změní se šablona a skript všechny soubory během krátké chvíle automaticky přegeneruje.

Ve vyvinuté aplikaci toto navržené řešení používají perlovské skripty \texttt{gen\_\-ope\-ra\-tors.pl} a \texttt{gen\_builtin.pl}, které generují C++ kód unárních operátorů, binárních operátorů a také všech zabudovaných funkcí. Návod na vytvoření nové zabudované funkce je uveden v~příloze~\ref{vytvoreni_nove_zabudovane_funkce} na straně \pageref{vytvoreni_nove_zabudovane_funkce}.


\clearpage
\section{Grafické uživatelské rozhraní}

\subsection{Oddělení od interpretu pro příkazovou řádku}
\label{oddeleni_od_interpretu_pro_prikazovou_radku}

Grafické uživatelské rozhraní je pouze alternativou k~interpretu pro příkazovou řádku, a proto by měly být oba zdrojové kódy co nejvíce odděleny. Ideálem zůstává samostatná knihovna zapouzdřující veškerý základní kód a dvě nezávislá uživatelská rozhraní -- konzolová a okenní aplikace. Vytvořené programy se dají zkompilovat nezávisle na sobě, sdílí většinu zdrojových kódů, nicméně nepoužívají žádnou knihovnu.

Některé třídy, typicky logování, není možné sdílet, a proto aplikace zavádí singleton \texttt{Ob\-ject\-Cre\-a\-tor}, jenž se stará o~vytváření a poskytování těchto objektů.

Pokud skript potřebuje vypsat chybové hlášení, požádá creator o~logovací třídu a s~její pomocí vypíše chybovou zprávu. V~případě, že aplikace běží v~textovém režimu, vrátí creator logovací třídu pro textový režim, která vypíše text na konzoli. U~grafického režimu je vrácen jiný datový typ vkládající text do logovacího okna. Oba objekty mají stejné rozhraní, protože jsou potomky společné třídy.

Ano, řešení používá návrhový vzor \textit{továrna}. Zůstaneme-li u~příkladu s~logováním, aplikace definuje celkem tři třídy pro výstup zpráv, abstraktní nadtřídu \texttt{Logger} a dva konkrétní potomky \texttt{CliLogger} a \texttt{GuiLogger}. Dále využívá, taktéž tři, továrny -- rozhraní \texttt{ObjectFactory} a jeho potomky \texttt{CliFactory} a \texttt{GuiFactory}. Rodičovská rozhraní jsou kompilována v~obou verzích programu, \texttt{Cli*} třídy pouze v~konzolové a \texttt{Gui*} třídy pouze v~grafické části.

Nyní se vrátíme zpět k~singletonu \texttt{ObjectCreator}, jenž poskytuje vlastní objekty. Při spuštění programu je mu předán některý z~potomků \texttt{ObjectFactory}, s~jehož pomocí může velice elegantně vytvořit správný typ objektů, aniž by věděl, ve které verzi programu se nachází. Pracuje pouze s~obecnými rozhraními rodičovských tříd a díky polymorfismu volá správné metody. Tovární třída je vytvořena na začátku funkce \texttt{main()}, ta se samozřejmě musí v~obou verzích programu taktéž lišit.


\subsection{Vlákna a jejich synchronizace}

Rozdíl mezi oběma verzemi aplikace je i~ve způsobu, jakým je skript spouštěn. Konzolový program se nemusí starat o~interakci s~uživatelem, a tudíž mu i~pro běh skriptu postačuje pouze jedno vlákno.

Okenní rozhraní, na rozdíl od něj, neslouží pouze pro jednorázové vykonání skriptu, ale umožňuje i~psaní kódu v~editoru, vizualizace a další činnosti, a proto musí být vykonávání skriptu vloženo do dalšího, pracovního, vlákna. Bez něj by déletrvající skript způsobil zamrznutí GUI a nemožnost debuggingu ani vizualizací.

Spolu s~druhým a dalšími vlákny v~aplikaci automaticky přichází i~požadavek na jejich synchronizaci. Podobně jako u~logování v~kapitole \ref{oddeleni_od_interpretu_pro_prikazovou_radku} na straně \pageref{oddeleni_od_interpretu_pro_prikazovou_radku} je vhodné napsat tento kód pro obě aplikace zvlášť.

Opět vytvoříme tři třídy, obecné rozhraní \texttt{Mutex} a konkrétní \texttt{CliMutex} a \texttt{GuiMutex}. Ro\-di\-čov\-ská třída požaduje po svých potomcích definovat pouze metody \texttt{lock()} a \texttt{unlock()}. Už bylo řečeno, že konzolová aplikace nepotřebuje synchronizaci vláken, a proto může \texttt{CliMutex} definovat tyto dvě funkce jako prázdné. \texttt{GuiMutex} využije služeb knihovny Qt a její třídu \texttt{QMutex}, ten je nutné definovat jako rekurzivní (\texttt{QMutex::Recursive}), aby mohl být se zanořením do funkcí zamknut v~daném vláknu opakovaně.

Aby se omezil počet možných chyb se synchronizací, byla dále, po vzoru \texttt{QMu\-tex\-Loc\-ker} z~knihovny Qt, vytvořena třída \texttt{MutexLocker}. Ta v~konstruktoru zamyká předaný mutex, v~destruktoru je automaticky odemknut. Nyní stačí na začátku synchronizované funkce vytvořit statický objekt tohoto datového typu a je zajištěno, že se \texttt{lock()} a \texttt{unlock()} zavolá automaticky. Makro \texttt{ACCESS\_MUTEX\_LOCKER} dále zkracuje celý zápis a zároveň umožňuje synchronizaci kompletně odstranit -- vhodné pro konzolovou aplikaci.

\begin{verbatim}
#ifdef DISABLE_THREAD_SYNCHRONIZATION
#define ACCESS_MUTEX_LOCKER
#else
#define ACCESS_MUTEX_LOCKER \
    MutexLocker mutexLocker(ObjectCreator::getInstance().getAccessMutex())
#endif
\end{verbatim}


\subsection{Spuštění a běh skriptu}

Z~uživatelského hlediska se skript spouští kliknutím na tlačítko \textit{Run}, které je namapováno na slot \texttt{runScript()} hlavního okna. Při jeho aktivaci se automaticky uloží všechny otevřené soubory, z~dokumentu v~aktivním editoru se vezme disková cesta se jménem skriptu, inicializuje se \texttt{ScriptThread} objekt (dědí ze třídy \texttt{QThread}) a spustí se nové pracovní vlákno.

V~metodě \texttt{run()} vlákna se nejdříve resetuje kontext skriptu do výchozího stavu a nastaví se požadované běhové parametry. Dále je naparsován vstupní soubor, vytvořen abstraktní strom syntaxe a spuštěna hlavní funkce skriptu.

Samotný skript komunikuje s~GUI vláknem spíše zřídka. Výjimkou je zasílání chybových a informačních zpráv k~zobrazení v~panelu s~textovým výstupem a signál o~pozastavení běhu breakpointem. Ten má za následek aktualizaci uživatelského rozhraní včetně panelu aktuálně definovaných proměnných a překreslení vizualizací.


\subsection{Ladění skriptu}

V~požadavcích na vytvářenou aplikaci je definováno, že musí umožňovat krokování skriptu, které ve své složitější formě odpovídá debuggingu. Kapitola \ref{podpora_debuggingu} na straně \pageref{podpora_debuggingu} analyzovala možnosti pozastavení skriptu a pro grafickou aplikaci přišla s~nápadem použít synchronizační prostředky vláken. \texttt{QWaitCondition} parametr je obsažen ve třídě \texttt{GuiContext} a vlastní pozastavení je možné realizovat zabudovanou funkcí \texttt{pauseExecution()}.

\begin{verbatim}
void GuiContext::pauseExecution(void)
{
    emit executionPaused();
    m_dbgMutex.lock();
    m_waitCondition.wait(&m_dbgMutex);
    m_dbgMutex.unlock();
}
\end{verbatim}

Implementovaný debugging podporuje celkem čtyři níže uvedené způsoby obnovení běhu skriptu známé z~běžných vývojových prostředí:

\begin{itemize}
\item Continue -- zastavit se na následujícím breakpointu.
\item Step into -- zastavit se na následujícím příkazu (i uvnitř volané funkce).
\item Step over -- zastavit se na následujícím příkazu, ignorovat příkazy uvnitř volaných funkcí.
\item Step out -- zastavit se po opuštění aktuálně prováděné funkce.
\end{itemize}

Zdrojový kód definuje tyto čtyři způsoby jako výčet \texttt{SteppingType}, jenž nabývá hodnot \texttt{ST\_NONE}, \texttt{ST\_INTO}, \texttt{ST\_OVER} a \texttt{ST\_OUT}. Aktuálně používané krokování je uloženo v~kontextu v~proměnné \texttt{m\_step\-ping\-Type}.

Nejjednodušším typem pokračování běhu je samozřejmě \textit{continue}. V~jeho případě se pouze nastaví krokování na \texttt{ST\_NONE} a probudí se vlákno skriptu. Tato funkce je volána z~GUI vlákna například po kliknutí uživatelem na odpovídající tlačítko v~nástrojové liště.

\begin{verbatim}
void GuiContext::debugRun(void)
{
    ACCESS_MUTEX_LOCKER;
    m_steppingType = ST_NONE;
    m_waitCondition.wakeAll();
}
\end{verbatim}

Další tři typy krokování však vyžadují o~něco více pozornosti. Jak bylo vidět před chvílí, spustit vlákno není nic složitého, problém spíše spočívá v~jeho opětovném pozastavení. Nejvhodnější místo pro tuto činnost je metoda kontextu \texttt{setPosition()}, jež má za úkol aktualizovat pozici ve skriptu -- podrobnosti viz kapitola \ref{pozice_v_kodu} na straně~\pageref{pozice_v_kodu}. Funkce se volá periodicky po každém provedeném příkazu a to je to, co nás zajímá.

Nová implementace na začátku zavolá metodu předka a poté se větví podle nastaveného typu krokování. Jak už bylo řečeno, \texttt{ST\_NONE} nedělá nic a \texttt{ST\_INTO} se pozastaví na nejbližším následujícím příkazu. \texttt{ST\_OVER} a \texttt{ST\_OUT} navíc berou v~úvahu úroveň zanoření na zásobníku volání funkcí, parametr \texttt{m\_callStackSize} byl na svou hodnotu nastaven spolu s~\texttt{m\_steppingType} ve chvíli, kdy uživatel kliknul na odpovídající tlačítko pro pokračování.

\begin{verbatim}
void GuiContext::setPosition(const CodePosition* pos)
{
    Context::setPosition(pos);

    switch(m_steppingType)
    {
    case ST_INTO:
        pauseExecution();
        break;

    case ST_OVER:
        if(getStackSize() <= m_callStackSize)
            pauseExecution();
        break;

    case ST_OUT:
        if(getStackSize() < m_callStackSize)
            pauseExecution();
        break;

    case ST_NONE:
    default:
        break;
    }
}
\end{verbatim}

Ačkoli se to nemusí zdát, pouze toto maličké množství kódu realizuje kompletní debugging ve vytvořené aplikaci. Jediný rozdíl, oproti běžným IDE, spočívá v~definici breakpointu, jedná se zde o~zabudovanou funkci zapsanou přímo do zdrojových kódů skriptu.

Jasnou výhodou z~implementačního hlediska je snadnost řešení. Kontext si nemusí vést databázi breakpointů a v~každém kroku pro všechny z~nich porovnávat, zda jejich pozice spadá mezi číslo řádku předchozího a aktuálního příkazu. Při zápisu do zdrojového kódu pozastaví breakpoint skript automaticky.

Druhou obrovskou výhodou je možnost parametrizace zabudované funkce, aktuální implementace zastavuje skript pouze, když je předán argument odpovídající logickému true. Jak ukazují následující příklady, díky jediné dodatečné podmínce ve zdrojových kódech, dostává programátor k~dispozici opravdu komplexní nástroj.

\begin{verbatim}
breakpoint(true);// Aktivní
breakpoint(false);// Neaktivní

breakpoint(cond1 || cond2);// Aktivní v závislosti na hodnotě proměnných

for(i = 0; i < 1000; ++i)
    breakpoint(i % 100 == 99);// Aktivní při každém stém průchodu cyklem
\end{verbatim}

Nevýhodou tohoto řešení je určitě statičnost, není možné definovat nový breakpoint po spuštění skriptu, protože zdrojový kód je již zpracován a změny se nevezmou v~úvahu. Další možnou ne\-vý\-ho\-dou je nestandardnost řešení oproti tomu, na co jsou programátoři zvyklí.


\subsection{Hlavní okno}

Hlavní okno aplikace dědí ze třídy \texttt{QMainWindow} a používá standardní rozvržení sestávající z~menu, nástrojových lišt a stavového řádku. Jedná se o~MDI aplikaci, centrální widget tvoří textové editory pro úpravu kódu, které se dají přepínat pomocí záložek.

Posledním výrazným prvkem jsou dokovatelná okna, která se dají libovolně přesouvat po celé ploše hlavního okna, skrývat a znovu zobrazovat a také kompletně vytrhávat ven do samostatných oken. Aplikace si pamatuje rozložení ovládacích prvků mezi jednotlivými spuštěními.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{img/screenshot.png}
\caption{Okno grafické aplikace}
\label{fig:main_window}
\end{center}
\end{figure}


\subsection{Textový editor}

Textový editor rozšiřuje standardní \texttt{QPlainTextEdit} a kvůli logickému oddělení částečně nesouvisejícího kódu používá dvě samostatné třídy: \texttt{TextEditorProgrammers}, z~níž dále dědí \texttt{TextEditor}.

Programátorský textový editor poskytuje zvýrazňování syntaxe, číslování řádek, zvýraznění aktivní řádky, automatické odsazování zdrojového kódu a inteligentní klávesu \textit{Home}. Od něj odvozená třída dále přidává vytváření, otevírání a ukládání souborů, hledání a nahrazování textu a další činnosti.


\subsubsection{Zvýrazňování syntaxe}

Pravidla a vlastní funkcionalitu zvýrazňování syntaxe definuje třída \texttt{Text\-E\-di\-tor\-High\-ligh\-ter}, jež vychází ze standardního \texttt{QSyntaxHighlighter} a je zaregistrována k~zobrazovanému dokumentu. V~jejím konstruktoru je definováno, jak se mají obarvovat klíčová slova, řetězce, čísla, komentáře a další elementy jazyka, tyto formáty jsou dále přiřazeny k~regulárním výrazům, pomocí kterých se hledají jejich textové reprezentace v~kódu skriptu.

Vlastní obarvování probíhá v~metodě \texttt{highlightBlock()}, jež prochází řetězec s~textem zvýrazňované řádky, v~něm hledá text odpovídající specifikovanému regulárním výrazu a při nalezení aplikuje daný formát. Celé řešení vychází z~oficiálního tutoriálu dodávanému ke knihovně Qt \cite{syntax_highlighter_example}.


\subsubsection{Zvýraznění aktuálního řádku}

Změní-li se pozice textového kurzoru v~dokumentu, editor emituje signál \texttt{cur\-sor\-Po\-si\-ti\-on\-Chan\-ged}. Tento signál je namapován na obslužný slot \texttt{highlightCurrentLine()}, jenž vytvoří objekt typu \texttt{QTextEdit::ExtraSelection}. Nastaví mu barvu pozadí a řekne, aby se roztáhl přes celou řádku, ve které se nachází kurzor. V~podstatě se jedná o~ekvivalentní zvýraznění, jaké probíhá při označení textu ke kopírování, editor jich podporuje libovolné množství.


\subsubsection{Číslování řádek}

Převážná část kódu pro přidání čísel řádek do levého okraje editoru se nachází ve třídě \texttt{TextEditorProgrammers}. Nejdříve je nutné vytvořit prázdné místo, do kterého se později vykreslí. K~tomu slouží funkce \texttt{updateLineNumberAreaWidth()} volaná například při přidání nového řádku do dokumentu nebo při změně velikosti okna. Požadovaná hodnota se získá vynásobením šířky jednoho znaku s~počtem znaků (číslic) v~textové reprezentaci počtu řádků.

Zobrazená čísla řádků se musí měnit zároveň s~posunem v~dokumentu. Požadavek na rolování oznamuje editor signálem \texttt{updateRequest}, stačí ho namapovat na slot \texttt{up\-da\-te\-Li\-ne\-Num\-ber\-A\-re\-a()}, ve kterém se pomocí standardní funkce \texttt{scroll()} posune viewport o~požadovaný počet pixelů.

Vlastní vykreslení čísel řádků se nachází ve funkci \texttt{lineNumberAreaPaintEvent()}, jež si najde číslo prvního viditelného řádku a poté v~cyklu kreslí číslice. Téměř celý kód byl převzat z~oficiálního tutoriálu knihovny Qt \cite{code_editor_example}.


\subsubsection{Indikace přednastavené šířky řádku}

Programátoři často zarovnávají své zdrojové kódy na 80 znaků, některé textové editory umožňují zobrazit vertikální linku, jež specifikuje tento pravý okraj dokumentu. Zdrojový kód pro její vykreslení je umístěn ve funkci \texttt{paintEvent()} textového editoru.


\subsubsection{Automatické odsazování textu}

Automatické odsazování textu je implementováno v~metodě \texttt{autoIndent()} editoru, která se volá po každém stisku klávesy \textit{Enter}. Funkce zkopíruje všechny bílé znaky (mezery, tabulátory) na začátku předchozího řádku do právě vytvořeného. Pokud navíc jako první ne-bílý znak nalezne složenou závorku, přidá ještě jeden tabulátor popř. odpovídající počet mezer.


\subsubsection{Inteligentní klávesa Home}

Nové chování klávesy \textit{Home} má na starost metoda \texttt{homeKey()}. Ve standardním nastavení přesouvá editor při jejím stisku textový kurzor na začátek aktuálního řádku a v~případě současného stisku klávesy \textit{Shift} vybírá mezilehlý text do bloku.

Nová implementace umožňuje, aby se kurzor nepřesouval přímo na začátek řádku, ale až za poslední ne-bílý znak na začátku řádku, tedy za odsazení tabulátory. V~případě, že se tam již nacházel, je přesunut na začátek a naopak. Vytvořený kód samozřejmě neporušuje chování klávesových zkratek \textit{Ctrl+Home} a \textit{Ctrl+Shift+Home}.


\subsubsection{Vyhledávání a nahrazování textu}

Editory z~knihovny Qt neposkytují dialogy na vyhledávání ani nahrazování textu. V~aplikaci je definují nově vytvořené třídy \texttt{DialogFind} a \texttt{DialogReplace}, které spolupracují s~kódem editoru.


\subsection{Textový výstup ze skriptu}

V~kapitole \ref{oddeleni_od_interpretu_pro_prikazovou_radku} na straně \pageref{oddeleni_od_interpretu_pro_prikazovou_radku} byla představena třída \texttt{GuiLogger}, jejímž prostřednictvím skript vypisuje text do okna s~výstupem. Aby mohl tento objekt pro mezivláknovou komunikaci využívat signály a sloty, musí být potomkem třídy \texttt{QObject} a dialog mezi vlákny musí probíhat podle schématu využívajícího mezilehlou frontu (angl. queued connection) \cite{qt_threads}.

\texttt{GuiLogger} poskytuje funkce pro předávání informačních, varovných a chybových zpráv a také pro standardní výstup ze skriptu. V~jejich tělech emituje signály s~textovými parametry, které jsou na druhém konci napojeny na obslužné sloty výstupního okna.

Panel je tvořen třídou \texttt{DockScriptOutput}, jež dědí od \texttt{QDockWidget} a zároveň zapouzdřuje \texttt{QTextBrowser}. Obslužné sloty převezmou text, podle jeho typu definují barvu a všechno předají metodě \texttt{append()}. Pozice ve zdrojových kódech se obalí HTML odkazem a vloží se spolu s~obarveným textem na konec logu.

Jediným důvodem pro použití třídy \texttt{QTextBrowser} namísto \texttt{QPlainTextEdit} je interní podpora odkazů. Jméno souboru a číslo řádku, na kterém se vyskytla chyba, je v~logu vždy klikací, daný soubor se otevírá v~editoru a kurzor je přesunut na požadovaný řádek.

Toto samozřejmě není standardní chování \texttt{QTextBrowser}, třída musí být pomocí funkce \texttt{set\-Open\-Links()} požádána, aby odkazy automaticky neotevírala, ale pouze generovala signály o~kliknutí. Předané URL má stejný formát, jaký byl zadán do \texttt{href} parametru odkazu, tedy jméno souboru a číslo řádku oddělené dvojtečkou. Obě části se od sebe oddělí a předají se jako parametry nově emitovaného signálu. Ten je poté již jednoduše napojen na \texttt{openAndScroll()} slot hlavního okna.


\subsection{Panel proměnných skriptu a panel zásobníku volání}

Panel s~výpisem hodnot lokálních proměnných obsahuje dva sloupce, jméno proměnné a její hodnotu. Aktualizace informací probíhá po každém pozastavení skriptu, všechny potřebné informace dodává kontext a jeho zásobník volání. Proměnné se procházejí v~cyklu a v~textové formě se vkládají do seznamu položek okna.

Hodnoty prvků, jež jsou uložené ve strukturovaných proměnných (pole, množina, graf atd.), se nezobrazují, místo nich je předáván pouze datový typ. Vypisovat všechny položky stoprvkového pole nebo grafu s~milionem vrcholů by bylo jednak nepřehledné a jednak neefektivně vytěžovalo procesor i~paměť. Místo toho je ve skriptu možné vyžít služeb přiřazení reference, kdy se prvek strukturovaného datového typu namapuje na jméno obyčejné proměnné a s~její pomocí se zobrazí požadovaná hodnota.

\begin{verbatim}
alias &= structure.some_array[57];
structure.some_array[57] = "some new value";
// alias variable contains the new value too
\end{verbatim}

Výpis zásobníku volání funguje téměř ekvivalentním způsobem jako zobrazování hodnot proměnných. Obsahuje tři sloupce, jméno funkce, jméno souboru a řádek, ze kterého byla funkce zavolána.

Po přidržení kurzoru myši nad jménem souboru se zobrazí \textit{tool tip} ukazující kompletní cestu k~souboru. Třída dále zpracovává signál o~dvojkliku myši, na jeho reakci otevírá soubor v~editoru a roluje na specifikovaný řádek.


\subsection{Vizualizace grafu}

\subsubsection{Propojení skriptu a vizualizací}

Skript komunikuje s~vizualizačním oknem výhradně pomocí zabudovaných funkcí, jejich jména začínají předponou \textit{vis-}. Podobně jako logování z~kapitoly \ref{oddeleni_od_interpretu_pro_prikazovou_radku} na straně \pageref{oddeleni_od_interpretu_pro_prikazovou_radku} i~tato funkcionalita musí být zobecněna, aby se dala používat s~grafickou aplikací a zároveň negenerovala chyby o~neexistujících funkcích při běhu z~konzole.

Rodičovská třída \texttt{VisualizationConnector} definuje potřebné rozhraní, současně implementuje těla všech svých metod jako prázdná. Nejedná se tedy o~čistě abstraktní třídu jako v~minulých případech. Zabudované funkce pro vizualizace komunikují s~GUI výhradně s~jejím prostřednictvím, resp. jejího potomka. Pokus o~přístup k~oknu z~konzolové aplikace proto nezpůsobí žádnou chybu, pouze se zavolá prázdná metoda komunikačního objektu, a to ničemu nevadí.

Odvozený \texttt{GuiVisualizationConnector} je o~něco zajímavější. Všechny zabudované vizualizační funkce mají obdobu v~některé z~metod konektoru, ten dále v~jejich těle generuje Qt signály, které jsou napojeny na obslužné sloty okna. Opačný směr komunikace probíhá pomocí obyčejného volání metod -- vizualizační okno nepotřebuje žádný zobecňovací mechanismus, ví, že konektor vždy existuje.


\subsubsection{Registrace objektů a rendering grafu}

Chce-li programátor skriptu zaregistrovat graf pro zobrazení ve vizualizačním okně, zavolá zabudovanou funkci \texttt{visRegister()}. Ta se přes metodu a signál konektoru spojí se slotem widgetu, jenž si uloží předaný objekt pro další použití.

Aplikace v~této části rozlišuje množiny a celé grafy. Současně s~objektem se předává i~řetězec se jménem pro menu, s~jehož pomocí může uživatel vypínat a opětovně zapínat zobrazování.

Vlastní rendering používá grafickou knihovnu OpenGL. Vrcholy se vykreslují jako \texttt{GL\_POINTS} body ve 3D prostoru, jež jsou pospojovány \texttt{GL\_LINES} čárami reprezentujícími hrany. Sou\-řad\-ni\-co\-vé koordináty se přebírají z~vlastností vrcholů pojmenovaných \textit{\_\_x}, \textit{\_\_y} a \textit{\_\_z}, jsou tedy implicitně přístupné i~kódu skriptu, jenž je může obyčejným přiřazením kdykoli změnit. U~hran je situace obdobná, při renderingu se ovšem používá pozice počátečního a koncového vrcholu.

Nutno podotknout, že není úkolem vizualizací ani skriptu souřadnicové koordináty nějakým způsobem vytvářet. Nestarají se, jak se jejich hodnoty dostaly do vrcholů, jednoduše před\-po\-klá\-da\-jí, že tam jsou, a používají je. O~jejich vytvoření se musí postarat tvůrce poskytovaného grafu -- ať už specifikací v~datovém souboru (viz příloha \ref{format_datovych_souboru_s_grafem} na straně \pageref{format_datovych_souboru_s_grafem}) či přímo v~kódu skriptu.

Další vlastnosti, které mohou ovlivnit rendering se jmenují \textit{\_\_r}, \textit{\_\_g}, \textit{\_\_b} a \textit{\_\_w}. První tři z~nich definují barvu ve formátu RGB, při jejím nalezení se pro tento konkrétní vrchol (hranu) nepoužije obecná barva množiny, se kterou byl registrován, ale tato konkrétní.

Čtvrtý z~parametrů umožňuje dodatečné vychýlení hrany ve směru souřadnicové osy \textit{z}. Je-li definován a zároveň je ovlivňování pozic povoleno (zabudovaná funkce \texttt{vis\-Use\-Weight\-When\-Pa\-in\-ting\-Ed\-ges()}), bere se při výpočtu pozice hrany v~úvahu i~její ohodnocení.

Představená funkcionalita souvisí s~požadavkem vedoucího práce. Jde o~to, že při vizualizaci speciálních grafů a při studiu difúzních algoritmů je výhodné graf zobrazovat tak, že se vrcholy zakreslí do roviny a hrany se zobrazí jako úsečky vedené paralelně \textit{nad} touto rovinou, přičemž výška hrany nad rovinou odpovídá její váze.


\subsubsection{Změna pohledu kamery na scénu}

Rendering používá celkem pět parametrů pro definici kamery. Jsou jimi \textit{x}, \textit{y} a \textit{z} pozice spolu s~\textit{x} a \textit{y} rotacemi. Kamera se při vykreslování nastavuje následovně.

\begin{verbatim}
glLoadIdentity();
glTranslatef(xpos, ypos, zpos - 10.0f);
glRotatef(xrot, 1.0f, 0.0f, 0.0f);
glRotatef(yrot, 0.0f, 1.0f, 0.0f);
\end{verbatim}

Uživatel má možnost stiskem levého tlačítka myši ve vizualizačním okně a táhnutím ovlivnit \textit{x} a \textit{y} pozici, k~posunutí na ose \textit{z} slouží kolečko. Táhnutí se stisknutým pravým tlačítkem ovlivňuje rotace, \textit{Ctrl} a \textit{Shift} modifikátory omezují natáčení pouze na horizontální resp. vertikální osu.

Zmíněné parametry se sdružují do třídy \texttt{VisualizationView}. Aplikace si udržuje kontejner těchto objektů, ukládání a pozdější aktivaci uloženého pohledu zpřístupňuje pomocí položek menu.


\subsubsection{Screenshot vizualizačního okna}

Díky knihovně Qt je kód funkce velice jednoduchý, zabírá pouze dva řádky. Funkce \texttt{grab\-Win\-dow()} třídy \texttt{QPixmap} sejme obsah vizualizačního okna a \texttt{save()} uloží data obrázku na disk. Alternativou by mohlo být OpenGL volání \texttt{glReadPixels()}, obě metody produkují stejné výsledky. Screenshot je rovněž zpřístupněn skriptu ve formě zabudované funkce.


\subsection{Konfigurace grafické aplikace}

Grafická aplikace, na rozdíl od konzolové, nepřebírá nastavení z~předaných argumentů, ale jednotlivé volby získává z~konfiguračního souboru. Databáze parametrů se uchovává v~singletonu \texttt{Settings}. Hodnoty jsou načteny jednorázově při konstrukci objektu, pozdější přístup poskytují odpovídající \texttt{set-} a \texttt{get-} metody. Zápis do souboru se provádí při každé změně, ne až při ukončení aplikace. Kód interně využívá služeb třídy \texttt{QSettings}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Testování}

%\begin{itemize}
%\item Způsob, průběh a výsledky testování.
%\item Srovnání s existujícími řešeními, pokud jsou známy.
%\end{itemize}

\section{Unit testy}
\label{unit_testy}

Aplikace nepoužívá žádný standardní framework pro automatické testování, místo toho při\-chá\-zí s~vlastním kódem zapouzdřeným ve třídě \texttt{Tests}. Ke spuštění jednotkových testů slouží metoda \texttt{run()}, která volá jednotlivé testovací rutiny.

\begin{verbatim}
void Tests::run(void)
{
    uint failed = 0;

    failed += !testDoubleDispatching();
    // ...

    cout << _("Number of failed tests: ") << failed << endl;
}
\end{verbatim}

Z~předchozího kódu je vidět, že jediným požadavkem na testovací funkci je její návratová hodnota. Funkce pomocí závěrečného \texttt{testResult()} vypisuje jméno testu (své jméno) a výsledek \textit{OK} či \textit{FAILED}.

\begin{verbatim}
bool Tests::testDoubleDispatching(void)
{
    bool result = true;

    CountPtr<Value> a(new ValueInt(5));
    CountPtr<Value> b(new ValueFloat(3.4f));
    CountPtr<Value> c(new ValueFloat(2.0f));

    verify(a->add(*b)->div(*c)->toString() == "4.2");// (5 + 3.4) / 2
    verify(a->mult(*c)->sub(*b)->toString() == "6.6");// (5 * 2) - 3.4

    return testResult(__FUNCTION__, result);
}
\end{verbatim}

Pozorný čtenář si jistě všiml slůvka \texttt{verify()}, jímž jsou obaleny testovací podmínky. Nejedná se o~funkci, ale o~makro, které vyhodnotí kód v~parametru, aktualizuje stavovou proměnnou \texttt{result} a v~případě chyby vypíše jméno souboru s~číslem řádku, kde k~ní došlo. Dále je zobrazena i~textová reprezentace testovacího kódu. V~podstatě se jedná o~alternativu ke standardnímu makru \texttt{assert()}, která však, v~případě neúspěchu, nemá za následek ukončení programu.

\begin{verbatim}
#define verify(expr)                                                   \
{                                                                      \
    result = result && (expr);                                         \
    if(!(expr))                                                        \
        cerr << __FILE__ << ":" << __LINE__ << "   " << #expr << endl; \
}
\end{verbatim}

Změníme-li pokusně hodnotu proměnné \textit{a} (jednoduchá emulace chyby), vypadá výstup z~provedených testů ná\-sle\-dov\-ně.

\begin{verbatim}
[ OK ]     testMemoryLeaks
tests.cpp:204   a->add(*b)->div(*c)->toString() == "4.2"
tests.cpp:205   a->mult(*c)->sub(*b)->toString() == "6.6"
[ FAILED ] testDoubleDispatching
[ OK ]     testValueStruct
[ OK ]     testValueString
...
Number of failed tests: 1
Number of memory leaks: 0
\end{verbatim}

Ke spuštění všech testovacích sekvencí slouží u~konzolové aplikace dodatečný argument pří\-ka\-zo\-vé řádky \texttt{--unit-tests}. Následující příkaz současně testuje i~úniky dynamické paměti, a to nejen nástrojem \textit{valgrind}, ale i~vlastním kódem - viz kapitola \ref{kontrola_uniku_pameti} na straně \pageref{kontrola_uniku_pameti}.

\begin{verbatim}
valgrind ./bbd --unit-tests ../samples/tests.txt
\end{verbatim}

Je nutné podotknout, že vytvořené unit testy poskytly neocenitelné služby při vývoji aplikace a především při testování změn ve fungování jednotlivých částí programu. Dokázaly velice rychle a efektivně detekovat místa v~kódu, která nepracovala tak, jak by měla -- mnohdy i~v~na první pohled nesouvisejících částech aplikace.


\section{Unit testy ve skriptu}

Obdobným způsobem, jakým jsou implementovány jednotkové testy z~předchozí kapitoly, funguje i~testovací skript \textit{samples/tests.txt}. Jedná se v~podstatě o~unit test zapsaný v~kódu skriptu a vykonávaný interpretem. Jeho obrovskou výhodou je, že se netestují pouze umělé případy navržené programátorem, ale přímo reálné interakce mezi všemi objekty interpretu.

Skript definuje testovací makro \texttt{tverify()} (jméno \texttt{verify()} se již používá pro zabudovanou funkci), které se opět rozbaluje na aktualizaci stavové proměnné. Jazyk nepodporuje výpis předaného kódu, a proto si musí programátor vystačit pouze se jménem souboru a číslem řádku, na kterém nastala chyba. Tato informace je však plně dostatečná, zvlášť ve spojení s~grafickým prostředím, kde se po kliknutí otevře místo chyby v~editoru.

\begin{verbatim}
define("tverify", "result = result && verify");
\end{verbatim}

Jednoduchá testovací funkce by mohla vypadat například následovně.

\begin{verbatim}
function testFactorial()
{
    result = true;

    tverify(factorial(1) == 1);
    tverify(factorial(2) == 2);
    tverify(factorial(3) == 6);

    return testResult(__FUNCTION__, result);
}
\end{verbatim}

Pouze pro zajímavost, takto vypadá kód, který vznikne v~lexikálním analyzátoru po rozbalení makra \texttt{tverify()} a dodání jména funkce.

\begin{verbatim}
function testFactorial()
{
    result = true;

    result = result && verify(factorial(1) == 1);
    result = result && verify(factorial(2) == 2);
    result = result && verify(factorial(3) == 6);

    return testResult("testFactorial", result);
}
\end{verbatim}


\section{Rychlost vykonávání skriptu, srovnávací testy}
\label{rychlost_vykonavani_skriptu_srovnavaci_testy}

Po vytvoření nového kompilátoru či interpretu nějakého programovacího jazyka je jistě dů\-le\-ži\-té znát, jak rychle dokáže vykonávat napsané programy. Byla navržena sada tří jednoduchých testů, které odpovídají na tuto otázku.

Všechny z~nich obsahují cyklus o~deseti milionech kroků. V~prvním se testuje provádění jednoduchých aritmetických operací a přístup k~proměnným (\texttt{tmp = i * 2;}), druhý rozšiřuje funkcionalitu o~indexování pole (\texttt{a[i \% SIZE] = i * 2;}) a třetí navíc přichází s~voláním funkcí (\texttt{tmp = func(i);}).

Tyto jednoduché testy byly dále přepsány do jazyků C++ a Perl, aby se mohlo s~něčím porovnávat. Zkompilované C++ programy jsou podle očekávání bezkonkurenčně nejrychlejší, doba běhu je neměřitelně malá. Při srovnání naměřených hodnot z~tabulky \ref{tab:benchmark} a následně vynesených do grafu \ref{fig:benchmark} vyplývá, že vytvořený interpret je přibližně osmkrát až patnáctkrát pomalejší než taktéž interpretovaný jazyk Perl. Výsledky byly v~podstatě očekávatelné, interpret se v~dané verzi nesnaží o~naprosto žádné optimalizace, a tudíž se není čemu divit.

\begin{table}
\begin{center}
\begin{tabular}{|l||r|r||r|}
\hline
\textbf{typ úlohy} & \textbf{perl [s]} & \textbf{bbd [s]} & \textbf{poměr [-]} \\
\hline \hline
\bf{variables} & 3.78 & 42.91 & 11.3 \\
\hline
\bf{arrays} & 6.91 & 57.11 & 8.3 \\
\hline
\bf{functions} & 10.48 & 160.38 & 15.2 \\
\hline
\end{tabular}
\end{center}
\caption{Rychlost vykonávání ve srovnání s~jazykem Perl}
\label{tab:benchmark}
\end{table}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=11.5cm]{img/benchmark.pdf}
\caption{Rychlost vykonávání ve srovnání s~jazykem Perl}
\label{fig:benchmark}
\end{center}
\end{figure}

Čtenáře možná překvapí výrazně pomalejší běh skriptu při volání funkcí než při jiných operacích. Kapitola \ref{strukturovane_skoky} na straně \pageref{strukturovane_skoky} se věnuje implementaci klíčového slova \texttt{return} pomocí výjimek a jak ukazuje graf \ref{fig:benchmark_func}, právě ony ho způsobují.

\begin{figure}[hb]
\begin{center}
\includegraphics[width=11.5cm]{img/benchmark_func.pdf}
\caption{Režie výjimek při návratu z~funkce}
\label{fig:benchmark_func}
\end{center}
\end{figure}

Cílem těchto testů bylo především získání orientačních hodnot. Interpret byl zkompilován s~optimalizačními volbami \texttt{-O2 -s -DNDEBUG} a vypnutými testy úniku paměti (viz kapitola \ref{kontrola_uniku_pameti} na straně \pageref{kontrola_uniku_pameti}). Neoptimalizovaná verze je cca. dvakrát pomalejší. Měření byla spuštěna na nezatíženém počítači několikrát, vždy s~obdobnými výsledky.


%\section{Použitelnost}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Závěr}

%\begin{itemize}
%\item Zhodnocení splnění cílů DP/BP a  vlastního přínosu práce (při formulaci je třeba vzít v potaz zadání práce).
%\item Diskuse dalšího možného pokračování práce.
%\end{itemize}

V~této práci byl navržen programovací jazyk pro psaní grafových algoritmů a vytvořen jeho interpret včetně komplexního vývojového prostředí. Jako implementační platforma byl pro základní kód zvolen jazyk C++, grafická verze aplikace je napsána s~pomocí knihovny Qt a vizualizace grafů dále využívají služeb OpenGL. Použité knihovny jsou multiplatformní, a tudíž je zaručena velice snadná přenositelnost mezi nejrůznějšími operačními systémy.

Všechny požadavky vyplývající ze zadání byly splněny, v~mnoha případech i~v~nevyžadované rozšířené formě. Příkladem budiž volitelná implementace orientovaných grafů, požadavek na krokování skriptu či schopnosti textového editoru pro psaní kódu. Aplikace ve výsledku umí pracovat s~naprosto všemi typy grafů, jednoduché krokování skriptu se vyvinulo v~obecný debugger a editor poskytuje nejen zvýrazňování syntaxe, ale i~automatické odsazování kódu, číslování řádků a další vymoženosti běžných programátorských editorů.

Jak ukázalo závěrečné testování, interpret má bohužel výrazné nedostatky v~rychlosti vykonávání kódu. Při porovnání s~ekvivalentními programy zapsanými v~jazyce Perl vychází přibližně osmi až patnáctinásobně pomalejší běh. Je pravda, že se vyvinutý interpret v~sou\-čas\-né verzi nesnaží o~naprosto žádné optimalizace, zde se zcela jistě nachází prostor pro další zlepšování.

Budoucnost aplikace a schopnosti nově vytvořeného jazyka leží především na rozšíření o~nové zabudované funkce, které zatím poskytují pouze velice málo možností k~praktickému nasazení například pro skriptování na úrovni operačního systému. Grafická část spolu s~výkonnými vizualizacemi grafů bude zcela jistě využívána při zkoumání difuzních algoritmů, o~nichž byla řeč v~samém úvodu práce. Je jasné, že během této činnosti určitě vznikne spousta nových požadavků na nejrůznější rozšíření a zlepšení.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

% http://www.fit.vutbr.cz/~martinek/latex/czechiso.html.cs.iso-8859-2
% http://cs.wikipedia.org/wiki/BibTeX

\bibliographystyle{czechiso}
{
\def\CS{$\cal C\kern-0.1667em\lower.5ex\hbox{$\cal S$}\kern-0.075em $}
\bibliography{reference}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\appendix


\chapter{Gramatika jazyka}
\label{gramatika_jazyka}

Při vytváření níže uvedené gramatiky se vycházelo z~předpisu pro jazyk Ansi C \cite{c_grammar}. Kromě těchto pravidel poskytuje jazyk také konstrukce \texttt{define} a \texttt{include}, ty se však zpracovávají na úrovni lexikálního analyzátoru, viz kapitola \ref{preprocesor} na straně \pageref{preprocesor}.

\begin{verbatim}
primary_expression
    : LEX_NULL
    | LEX_TRUE
    | LEX_FALSE
    | LEX_INT
    | LEX_IDENTIFIER
    | LEX_FLOAT
    | LEX_STRING
    | '(' expression ')'
    ;

postfix_expression
    : primary_expression
    | postfix_expression '[' expression ']'
    | LEX_IDENTIFIER '(' ')'
    | LEX_IDENTIFIER '(' argument_expression_list ')'
    | postfix_expression '.' LEX_IDENTIFIER
    | postfix_expression '.' LEX_IDENTIFIER '(' ')'
    | postfix_expression '.' LEX_IDENTIFIER '(' argument_expression_list ')'
    | postfix_expression LEX_INC_OP
    | postfix_expression LEX_DEC_OP
    ;

argument_expression_list
    : assignment_expression
    | argument_expression_list ',' assignment_expression
    ;

unary_expression
    : postfix_expression
    | LEX_INC_OP unary_expression
    | LEX_DEC_OP unary_expression
    | '+' unary_expression
    | '-' unary_expression
    | '!' unary_expression
    ;

multiplicative_expression
    : unary_expression
    | multiplicative_expression '*' unary_expression
    | multiplicative_expression '/' unary_expression
    | multiplicative_expression '%' unary_expression
    ;

additive_expression
    : multiplicative_expression
    | additive_expression '+' multiplicative_expression
    | additive_expression '-' multiplicative_expression
    ;

relational_expression
    : additive_expression
    | relational_expression '<' additive_expression
    | relational_expression '>' additive_expression
    | relational_expression LEX_LE_OP additive_expression
    | relational_expression LEX_GE_OP additive_expression
    ;

equality_expression
    : relational_expression
    | equality_expression LEX_EQ_OP relational_expression
    | equality_expression LEX_NE_OP relational_expression
    ;

logical_and_expression
    : equality_expression
    | logical_and_expression LEX_AND_OP equality_expression
    ;

logical_or_expression
    : logical_and_expression
    | logical_or_expression LEX_OR_OP logical_and_expression
    ;

conditional_expression
    : logical_or_expression
    | logical_or_expression '?' expression ':' conditional_expression
    ;

assignment_expression
    : conditional_expression
    | unary_expression '=' assignment_expression
    | unary_expression LEX_MUL_ASSIGN assignment_expression
    | unary_expression LEX_DIV_ASSIGN assignment_expression
    | unary_expression LEX_MOD_ASSIGN assignment_expression
    | unary_expression LEX_ADD_ASSIGN assignment_expression
    | unary_expression LEX_SUB_ASSIGN assignment_expression
    | unary_expression LEX_REF_ASSIGN assignment_expression
    ;

expression
    : assignment_expression
    ;

statement
    : compound_statement
    | expression_statement
    /* "parser.y: conflicts: 1 shift/reduce" is ok */
    | LEX_IF '(' expression ')' statement
    | LEX_IF '(' expression ')' statement LEX_ELSE statement
    | LEX_WHILE '(' expression ')' statement
    | LEX_FOR '(' expression_statement expression_statement ')' statement
    | LEX_FOR '(' expression_statement expression_statement
        expression ')' statement
    | LEX_FOREACH '(' LEX_IDENTIFIER ';' expression ')' statement
    | LEX_BREAK ';'
    | LEX_CONTINUE ';'
    | LEX_RETURN ';'
    | LEX_RETURN expression ';'
    | LEX_GLOBAL LEX_IDENTIFIER ';'
    ;

expression_statement
    : ';'
    | expression ';'
    ;

compound_statement
    : '{' '}'
    | '{' block_item_list '}'
    ;

block_item_list
    : statement
    | block_item_list statement
    ;

function_definition
    : function_and_name '(' parameter_list ')' compound_statement
    | function_and_name '(' ')' compound_statement
    ;

function_and_name
    : LEX_FUNCTION LEX_IDENTIFIER
    ;

parameter_list
    : LEX_IDENTIFIER
    | parameter_list ',' LEX_IDENTIFIER
    ;

start
    : /* empty */
    | start function_definition
    ;
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Formát datových souborů s~grafem}
\label{format_datovych_souboru_s_grafem}

Soubory ukládající grafy používají strukturu uvedenou níže. Jedná se o~textový formát, od\-dě\-lo\-va\-čem hodnot může být libovolný počet bílých znaků (mezera, tabulátor, nový řádek).

\begin{verbatim}
is_directed

number_of_vertices   number_of_edges

number_of_properties_for_vertices   names_of_properties_for_vertices
number_of_properties_for_edges      names_of_properties_for_edges

vertex_id   values_of_properties
vertex_id   values_of_properties
vertex_id   values_of_properties
...

vertex_id   vertex_id   values_of_properties
vertex_id   vertex_id   values_of_properties
vertex_id   vertex_id   values_of_properties
...
\end{verbatim}

Jako příklad následuje kompletní výpis definice jednoduchého grafu, který se ve vizualizačním okně zobrazí jako domeček ze známého úkolu \textit{nakreslit jedním tahem}.

\begin{verbatim}
1

5 8

3    __x __y __z
1    __w

0    -1  1 0
1     1  1 0
2     1 -1 0
3    -1 -1 0
4     0  2 0

3 0    0.0
0 1    0.0
1 3    0.0
3 2    0.0
2 0    0.0
0 4    0.0
4 1    0.0
1 2    0.0
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Vytvoření nové zabudované funkce}
\label{vytvoreni_nove_zabudovane_funkce}

Při vytváření nové zabudované funkce, je dobré postupovat podle následujících kroků:

\begin{enumerate}
\item V~souboru \texttt{../samples/tests.txt} vytvořit unit test (viz kapitola \ref{unit_testy} na straně \pageref{unit_testy}).
\item V~souboru \texttt{gen\_builtin.pl}:
\begin{enumerate}
\item Napsat \texttt{\$funcdecl} deklaraci/dokumentaci funkce.
\item Definovat kód pro vložení hlavičkových souborů.
\item Definovat tělo zabudované funkce.
\item Zavolat funkci \texttt{genBFClass()}.
\end{enumerate}
\item Přegenerovat zdrojové kódy pomocí \texttt{make builtin} nebo \texttt{make rebuild}.
\item Přidat nové \texttt{.hpp} a \texttt{.cpp} soubory do projektů.
\item Zkompilovat aplikaci.
\item Otestovat kód pomocí \texttt{valgrind ./bbd --unit-tests ../samples/tests.txt}.
\end{enumerate}

Jako příklad následuje kompletní výpis kódu zabudované funkce \texttt{getAdjacencyMatrix()}, která pro\-gra\-má\-to\-ro\-vi skriptu zpřístupňuje matici sousednosti grafu.

\begin{verbatim}
$funcdecl = 'getAdjacencyMatrix(graph) : array';

$include = <<END_OF_CODE;
#include "valuegraph.hpp"
END_OF_CODE

$code = <<END_OF_CODE;
    ValueGraph* g = NULL;

    if((g = par[0]->toValueGraph()) != NULL)
        return g->getAdjacencyMatrix();
    else
    {
        WARN_P(_("Bad parameters type: $funcdecl"));
        return VALUENULL;
    }
END_OF_CODE

genBFClass('getAdjacencyMatrix', 'NodeBuiltinGetAdjacencyMatrix', 1,
    $code, $include);
\end{verbatim}

Při dodržení výše uvedeného postupu stačí pouze vytvořit tento zdrojový kód, přegenerovat zabudované funkce, přidat novou třídu do projektových souborů a začít nově vytvořenou funkci používat.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\twocolumn

\chapter{Hierarchie tříd}
\label{hierarchie_trid}

\begin{verbatim}
CountPtr< TYPE >
ObjectCreator
BaseObject
.   CallStackItem
.   CodePosition
.   Context
.   .   GuiContext (+ QObject)
.   ExitValue
.   Lexan
.   LexanIterator
.   .   LexanIteratorFile
.   .   LexanIteratorString
.   Logger
.   .   CliLogger
.   .   GuiLogger (+ QObject)
.   Node
.   .   NodeBinary
.   .   .   NodeBinaryAdd
.   .   .   NodeBinaryAnd
.   .   .   NodeBinaryAss
.   .   .   NodeBinaryAssAdd
.   .   .   NodeBinaryAssDiv
.   .   .   NodeBinaryAssMod
.   .   .   NodeBinaryAssMult
.   .   .   NodeBinaryAssRef
.   .   .   NodeBinaryAssSub
.   .   .   NodeBinaryDiv
.   .   .   NodeBinaryEq
.   .   .   NodeBinaryGe
.   .   .   NodeBinaryGt
.   .   .   NodeBinaryIndex
.   .   .   NodeBinaryLe
.   .   .   NodeBinaryLt
.   .   .   NodeBinaryMember
.   .   .   NodeBinaryMod
.   .   .   NodeBinaryMult
.   .   .   NodeBinaryNe
.   .   .   NodeBinaryOr
.   .   .   NodeBinarySub
.   .   NodeBlock
.   .   NodeCondition
.   .   NodeEmptyCommand
.   .   NodeForeach
.   .   NodeFunction
.   .   .   NodeFunctionBuiltin
.   .   .   .   NodeBuiltinArray
.   .   .   .   NodeBuiltinAssert
.   .   .   .   etc.
.   .   .   NodeFunctionScript
.   .   NodeFunctionCall
.   .   NodeGlobal
.   .   NodeJumpBreak
.   .   NodeJumpContinue
.   .   NodeLoop
.   .   NodePosition
.   .   NodeUnary
.   .   .   NodeUnaryDecPost
.   .   .   NodeUnaryDecPre
.   .   .   NodeUnaryIncPost
.   .   .   NodeUnaryIncPre
.   .   .   NodeUnaryNot
.   .   .   NodeUnaryReturn
.   .   .   NodeUnarySub
.   .   NodeValue
.   ObjectFactory
.   .   CliFactory
.   .   GuiFactory
.   StringTable
.   Tests
.   Value
.   .   ValueArray
.   .   ValueBool
.   .   ValueEdge
.   .   ValueFloat
.   .   ValueGraph
.   .   ValueIdentifier
.   .   ValueInt
.   .   ValueNull
.   .   ValueReference
.   .   ValueSet
.   .   ValueString
.   .   ValueStruct
.   .   ValueVertex
.   VisualizationConnector
.   .   GuiVisualizationConnector (+ QObject)
MutexLocker
Mutex
.   CliMutex
.   GuiMutex
Settings
QObject
.   VisualizationItemData
.   VisualizationView
.   Qt classes
.   .   QMainWindow
.   .   .   MainWindow
.   .   QDockWidget
.   .   .   DockCallStack
.   .   .   DockFiles
.   .   .   DockScriptOutput
.   .   .   DockVariables
.   .   .   DockVisualization
.   .   QDialog
.   .   .   DialogFind
.   .   .   DialogIncludeDirs
.   .   .   DialogReplace
.   .   .   DialogReplaceConfirmation
.   .   .   DialogScriptParameters
.   .   .   DialogSettings
.   .   .   DialogSettingsEditor
.   .   .   DialogSettingsVisualization
.   .   QPlainTextEdit
.   .   .   TextEditorProgrammers
.   .   .   .   TextEditor
.   .   QWidget
.   .   .   TextEditorLines
.   .   QSyntaxHighlighter
.   .   .   TextEditorHighlighter
.   .   QGLWidget
.   .   .   Visualization
.   .   QThread
.   .   .   ScriptThread
\end{verbatim}

\onecolumn


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Seznam použitých zkratek}

\begin{description}
\setlength{\labelwidth}{2.5cm}
\setlength{\itemindent}{1.5cm}
\item[AST] Abstract Syntax Tree
\item[CLI] Command Line Interface
\item[GNU] GNU's Not Unix!
\item[GUI] Graphics User Interface
\item[HTML] Hyper Text Markup Language
\item[I/O] Input/Output
\item[LALR] Look Ahead Left to Right (Grammar)
\item[MDI] Multiple Document Interface
\item[OOP] Object Oriented Programming
\item[OpenGL] Open Graphics Library
\item[PDF] Portable Document Format
\item[PNG] Portable Network Graphics
\item[RGB] Red Green Blue
\item[RTTI] Run-Time Type Information
\item[STL] Standard Template Library
\item[SVG] Scalable Vector Graphics
\item[SVN] Subversion
\item[UML] Unified Modeling Language
\item[URL] Uniform Resource Locator
\item[XML] eXtensible Markup Language
\end{description}
\vdots


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Obsah přiloženého CD}

\begin{verbatim}
cd
|-- bbd
|-- bbdgui
|-- samples
|-- graphs
|-- man
|   |-- html
|   |-- php
|-- doc
|-- benchmarks
|-- text
|-- presentation
|-- svn
|-- svnstat
\end{verbatim}

Adresáře \texttt{bbd} a \texttt{bbdgui} obsahují kompletní zdrojové kódy konzolové a grafické aplikace. Projektové soubory zahrnují vývojová prostředí Qt Creator, Code::Blocks a Makefile. Adresáře \texttt{samples} a \texttt{graphs} ukládají ukázkové skripty ve vytvořeném programovacím jazyce a několik datových souborů s~testovacími grafy. Kompilace a spuštění jsou plně popsány v~uživatelském manuálu, který se nachází v~adresáři \texttt{man}. Vývojová dokumentace, včetně základních UML diagramů, generovaná ze zdrojových kódů nástrojem Doxygen je uložena v~adresáři \texttt{doc}.

V~\texttt{benchmarks} jsou k~nalezení všechny prostředky sloužící k~měření výkonu interpretu z~kapitoly \ref{rychlost_vykonavani_skriptu_srovnavaci_testy} na straně \pageref{rychlost_vykonavani_skriptu_srovnavaci_testy}. Jedná se o~zdrojové kódy testovacích sestav pro vyvinutý interpret, Perl a C++, dále spouštěcí skripty, formátování logů a konfigurační soubory pro Gnuplot s~výstupem ve formátu PNG a SVG, včetně následné konverze SVG na PDF. Vše je plně automatizováno, stačí nainstalovat potřebné nástroje a spustit příkaz \texttt{make run}.

Ve složce \texttt{text} je uložen kompletní text této diplomové práce ve formátu PDF a zdrojové soubory pro typografický systém \LaTeX. Prezentace diplomové práce se nachází v~\texttt{presentation}, jedná se o~formát PDF a zdrojové kódy napsané v~\LaTeX~Beamer.

Adresář \texttt{svn} obsahuje dump SVN repositáře sloužícího pro vývoj a \texttt{svnstat} statistiky o~tomto repositáři vygenerované nástrojem StatSVN.


\end{document}
