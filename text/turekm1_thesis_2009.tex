%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

%% History:
% Pavel Tvrdik (26.12.2004)
%  + initial version for PhD Report
%
% Daniel Sykora (27.01.2005)
%
% Michal Valenta (3.12.2008)
% rada zmen ve formatovani (diky M. Duškovi, J. Holubovi a J. Žďárkovi)
% sjednoceni zdrojoveho kodu pro anglickou, ceskou, bakalarskou a diplomovou praci


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\documentclass[11pt,twoside,a4paper]{book}
\usepackage[czech, english]{babel}

%\usepackage[T1]{fontenc} % pouzije EC fonty
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
%\usepackage{indentfirst} %1. odstavec jako v cestine.

\usepackage{k336_thesis_macros}
\usepackage{url}
\DeclareUrlCommand\url{\def\UrlLeft{<}\def\UrlRight{>} \urlstyle{tt}}

\usepackage[left=3.5cm,top=3.5cm,right=2cm,bottom=3cm]{geometry}

\newcommand\TypeOfWork{Diplomová práce} % \typeout{Diplomova prace}
%\newcommand\TypeOfWork{Master's Thesis}   \typeout{Master's Thesis}


% http://www.fel.cvut.cz/cz/education/bk/prehled.html

\newcommand\StudProgram{Elektrotechnika a informatika, strukturovaný,\\Navazující magisterský}
%\newcommand\StudProgram{Electrical Engineering and Information Technology}  % master program

\newcommand\StudBranch{Výpočetní technika}   % pro prgoram EaI mag. (dobihajici i strukt.)
%\newcommand\StudBranch{Computer Science and Engineering}  % master programe


\newcommand\WorkTitle{Interpret grafových algoritmů}
\newcommand\FirstandFamilyName{Bc. Michal Turek}
\newcommand\Supervisor{RNDr. Marko Genyk-Berezovskyj}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\usepackage[
pdftitle={\WorkTitle},
pdfauthor={\FirstandFamilyName},
bookmarks=true,
colorlinks=true,
breaklinks=true,
urlcolor=red,
citecolor=blue,
linkcolor=blue,
unicode=true,
]
{hyperref}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\begin{document}

\selectlanguage{czech}
%\selectlanguage{english}

\iflanguage{czech}{
%	 \typeout{************************************************}
%	 \typeout{Zvoleny jazyk: cestina}
%	 \typeout{Typ prace: \TypeOfWork}
%	 \typeout{Studijni program: \StudProgram}
%	 \typeout{Obor: \StudBranch}
%	 \typeout{Jmeno: \FirstandFamilyName}
%	 \typeout{Nazev prace: \WorkTitle}
%	 \typeout{Vedouci prace: \Supervisor}
%	 \typeout{***************************************************}
	 \newcommand\Department{Katedra počítačů}
	 \newcommand\Faculty{Fakulta elektrotechnická}
	 \newcommand\University{České vysoké učení technické v Praze}
	 \newcommand\labelSupervisor{Vedoucí práce}
	 \newcommand\labelStudProgram{Studijní program}
	 \newcommand\labelStudBranch{Obor}
}{
%	 \typeout{************************************************}
%	 \typeout{Language: english}
%	 \typeout{Type of Work: \TypeOfWork}
%	 \typeout{Study Program: \StudProgram}
%	 \typeout{Study Branch: \StudBranch}
%	 \typeout{Author: \FirstandFamilyName}
%	 \typeout{Title: \WorkTitle}
%	 \typeout{Supervisor: \Supervisor}
%	 \typeout{***************************************************}
	 \newcommand\Department{Department of Computer Science and Engineering}
	 \newcommand\Faculty{Faculty of Electrical Engineering}
	 \newcommand\University{Czech Technical University in Prague}
	 \newcommand\labelSupervisor{Supervisor}
	 \newcommand\labelStudProgram{Study Programme}
	 \newcommand\labelStudBranch{Field of Study}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\coverpagestarts


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\acknowledgements
\noindent

\noindent Rád bych poděkoval svému vedoucímu RNDr. Marku Genyk-Berezovskému za jeho při\-po\-mín\-ky a cené rady při tvoření práce.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

% TODO: update information
\declaration{V Krasnojarsku dne 12.\,6.\,2009}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\abstractpage
The core of this diploma thesis is design and implementation of a special language based on C, which will be used for the graph manipulations. Integrated development environment was developed, it consists of a text editor for programmers, debugger and visualization window. The progress of the interpreted graph algorithm can be displayed using 3D graphics.

\vglue60mm

\noindent{\Huge \textbf{Abstrakt}}
\vspace{8ex}

\noindent
Jádrem diplomové práce je návrh a implementace speciálního programovacího jazyka za\-lo\-že\-né\-ho na syntaxi C, který slouží pro manipulaci s grafy. Bylo vytvořeno integrované vývojové prostředí sestávající z programátorsky zaměřeného textového editoru, debuggeru a vizualizačního okna. Průběh interpretovaného grafového algoritmu může být zobrazován pomocí 3D grafiky.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\tableofcontents
\listoffigures
\listoftables


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\mainbodystarts

\parskip=5pt plus 3pt minus 3pt
\parindent=0em


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Úvod}

Algoritmy \textit{difuze} slouží pro zpracování obrazů. Každý, kdo se jimi zabývá, ví, že fungují, ale nikdo neví, jakým způsobem \textit{přesně} fungují. Výstupem tohoto projektu bude integrované vývojové prostředí pro psaní, ladění a vizualizaci průběhu takovýchto algoritmů.

Vstupními daty je obrázek a výstupem například, ve které jeho části se nachází objekt s definovanými vlastnostmi, kde se vyskytuje pozadí a podobně. Obrázek je převeden na speciální graf s několika vrcholy pro každý pixel a pospojovanými ohodnocenými hranami. Difuzní algoritmus pracuje s lokálními částmi grafu, iterativně aktualizuje ohodnocení hran a končí poté, co je splněna globální podmínka. Zadání může být tedy zobecněno z práce s obrázky na jednoduché grafové operace.

Cílem diplomové práce byl návrh a implementace jazyka založeného na syntaxi C, který slouží pro manipulaci s grafy. Jazyk má podporu pro základní datové typy, jako jsou celá a desetinná čísla, řetězce, pole a struktury. Proměnné mohou být lokální i globální, bez deklarací. Výčet kontrolních struktur sestává z \texttt{if-else} podmínek, \texttt{for}, \texttt{while} a \texttt{foreach} cyklů, deklarace funkcí a jejich volání. \texttt{Include} a \texttt{define} direktivy preprocesoru jsou implementovány na úrovni lexikálního analyzátoru. Jazyk nepodporuje ukazatele ani objektově orientované programování.

Speciální datové typy zahrnují grafy, vrcholy, hrany, množiny vrcholů a množiny hran. Interpret obsahuje zabudované funkce pro vytváření a rušení těchto proměnných, vracení sousedů daného vrcholu a další. Každému vrcholu a hraně může být přiřazen libovolný počet dalších hodnot, k přístupu k nim slouží jméno předávané tečkovou notací \texttt{objekt.vlastnost}. Speciální řídící stuktury pro zpracování komplexních proměnných jsou implementovány na bázi iterátorů, jež jsou interně volané i ve \texttt{foreach} cyklu.

Grafické uživatelské rozhraní sestává především z programátorsky zaměřeného textového editoru, který poskytuje zvýrazňování syntaxe, číslování řádků, zvýraznění aktuálního řádku, automatické odsazování a inteligentní klávesu \texttt{Home}. Všechny ostatní části aplikace jsou tvořeny panely, které mohou být uživatelem libovolně přesunuty na jiné místo, skryty a nebo také \textit{vytrhnuty} z hlavního do samostatného okna. To je výhodné především při používání dvou monitorů. V panelech je možné zobrazit výstup z parsování a interpretace skriptu, zásobník volání funkcí, seznam definovaných proměnných a vizualizační okno.

Vizualizace jsou přímo propojené s debuggingem skriptu. Vykonávání kódu může být pozastaveno breakpointem a poté krokováno s možností vstupování do funkcí (step in), opuštění dané funkce (step out) či její vykonání a opětovné pozastavení (step over). Při každém zastavení skriptu se aktualizuje panel zásobníku volání funkcí, seznam definovaných proměnných a vizualizace grafu, s níž se dá následně otáčet, přibližovat, oddalovat a provádět další 3D operace. Graf může být nahrán jak kódem skriptu, tak uživatelem ve vizualizačním okně.

Základní kód interpretu a rozhraní pro příkazovou řádku je napsáno v jazyce C++ s využitím parser generátoru Bison (LALR gramatika) a nezávisí na žádné externí knihovně kromě standardního STL. Tato část je tudíž zkompilovatelná na libovolné platformě, pro kterou existuje C++ kompilátor. Grafická část aplikace používá knihovnu Qt a vizualizace OpenGL, obě jsou dostupné na všech majoritních operačních systémech.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Popis problému, specifikace cíle}

% TODO: delete
%\begin{itemize}
%\item Popis řešeného problému, vymezení cílů DP/BP a požadavků na implementovaný systém.
%\item Popis struktury DP/BP ve vztahu k vytyčeným cílům.
%\item Rešeršní zpracování existujících implementací, pokud jsou známy.
%\end{itemize}


\section{Požadavky na aplikaci}

Navrhněte a implementujte interpret jazyka, který bude zaměřen na manipulaci s grafy. Jazyk bude obsahovat základní datové struktury nezbytné pro manipulaci s grafy a bude tak podporovat efektivní zápis grafových algoritmů. Interpret vybavte uživatelským rozhraním skládajícím se z editoru pro zápis algoritmu a dále grafickým oknem zobrazujícím interaktivně průběh algoritmu na konkrétním grafu. V grafické části aplikace využijte knihovnu OpenGL.

Zásadní jsou neorientované grafy, implementace orientovaných je volitelná.

\subsection{Navrhovaný jazyk}

Jazykové konstrukce by měly být podobné jazyku C. Zahrnují základní datové typy, datové a řídící struktury

\begin{itemize}
\item celá a desetinná čísla
\item pole
\item podmínky, cykly, deklarace a volání funkcí
\item výstup textu na vlastní konzoli
\item direktiva \texttt{include} v jednoduché verzi, tj. nikoli hlavičky, ale celé soubory

\item zvažte
	\begin{itemize}
	\item datový typ boolean
	\item znaky a řetězce, v jednoduché formě bez složitých funkcí pro manipulaci
	\item ukazatele a struktury jako v jazyce C
	\item objektově orientované vlastnosti
	\item čtení a zápis souborů, jde především o načítání specifikací grafu z externích souborů
	\end{itemize}

\item specifické elementy jazyka
	\begin{itemize}
	\item primitivní typy
		\begin{itemize}
		\item graf, vrchol, hrana
		\item množina vrcholů, množina hran
		\end{itemize}
	\item základní funkce
		\begin{itemize}
		\item vytvoř/smaž graf/hranu/vrchol
		\item ohodnoť hranu/vrchol
		\item vrať všechny sousedy daného vrcholu
		\item vytvoř/zruš množinu vrcholů/hran, přidej/odeber vrchol/hranu
		\item vrať stupeň vrcholu
		\end{itemize}
	\item řídící struktury
		\begin{itemize}
		\item pro všechny sousedy daného vrcholu vykonej \texttt{příkaz}
		\item pro všechny vrcholy/hrany v dané množině vykonej \texttt{příkaz}
		\item pro všechny vrcholy/hrany grafu vykonej \texttt{příkaz}
		\end{itemize}
	\end{itemize}
\end{itemize}


\subsection{Textový editor}

Textový editor by měl být programátorsky zaměřený, zvýrazňování syntaxe je vítáno. Další vymoženosti podle dohody a možností.


\subsection{Zobrazovací jednotka, vizualizace}

Vizualizační jednotka zobrazuje aktuálně zpracovávaný graf ve 3D, nemusí to být editor, ve kterém je možné měnit strukturu grafu. Uživatel má možnost graf interaktivně natáčet, přibližovat, oddalovat a posouvat v libovolném směru. Dále vůže zapnout a vypnout zobrazování jednotlivých částí grafu, aby bylo možné dosáhnout méně přeplněného výstupu.

Pokud bude v jazyce možnost přidávat barevné (texturové) atributy vrcholům, hranám nebo jejich množinám, promítaly by se i do zobrazení. Zobrazovací okno má vlastní možnost načtení grafu, aplikace umožní volit, zda má algoritmus pracovat s grafem, který je v grafickém okně nebo zda si jej načte sám podle zápisu v kódu.


\subsection{Manipulace s grafem, debugger}

Interpretace kódu může být krokována, při jejím pozastavení se překreslí vizualizační okno a tím se aktualizauje i pohled na graf. Dokud není vydán příkaz k dalšímu kroku, je možné s grafem posouvat, natáčet ho a podobně. Parametry samotného grafu během průběhu programu není vhodné měnit, avšak parametry zobrazení nejspíše ano (barvy, měřítka a podobně). Debugging není třeba nijak zvlášť podporovat, postačí konzole, kam si programátor může vypsat ladící a trasovací tisky.


\subsection{Systémové požadavky}

\begin{itemize}
	\item Verze pro příkazovou řádku
		\begin{itemize}
		\item platformy \texttt{i386} a \texttt{amd64}, podpora dalších volitelná
		\item operační systémy \texttt{GNU/Linux}, \texttt{MS Windows} (založený na NT) a \texttt{MacOS}, podpora dalších volitelná
		\item procesor min. 1 GHz
		\item operační paměť min. 2 GB RAM, v grafech se předpokládají miliony vrcholů
		\end{itemize}

	\item Grafická verze
		\begin{itemize}
		\item grafická karta s podporou OpenGL (např. \texttt{nVidia GeForce 2} a novější)
		\item nainstalované OpenGL ovladače a Qt4 knihovny
		\item rozlišení monitoru min. 1024x768
		\end{itemize}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Analýza a návrh řešení}

% TODO: delete
% Analýza a návrh implementace (včetně diskuse různých alternativ a volby im\-ple\-men\-tač\-ní\-ho prostředí).

\section{Obecný postup řešení}

Základním cílem tohoto projektu je vyvinout integrované vývojové prostředí pro programovací jazyk orientovaný na manipulace s grafy. Tato komplexní úloha může být rozdělena na několik oddělených částí, které budou řešeny v následujícím pořadí.

\begin{enumerate}
\item Návrh jazyka pro manipulace s grafy, který odpovídá všem požadavkům
\item Návrh reprezentace grafů v aplikaci, jak k nim bude přistupováno z interpretu
\item Implementace lexikálního analyzátoru a parseru
\item Implementace interpretu pro příkazovou řádku
\item Návrh a implementace grafického vývojového prostředí
\item Implementace vizualizačního okna, propojení s interpretem
\end{enumerate}


\section{Volba jazyka a knihoven pro implementaci}

Na samém začátku je možné uvažovat tři běžně používané jazyky pro tvorbu sys\-té\-mo\-vých aplikací: C++, Javu a C\#. Třetí z nich může být automaticky vyškrtnut, protože neodpovídá zásadnímu požadavku na přenositelnost a především odporu autora práce. Jazyk C++ je portovatelný na úrovni zdrojových kódů a Java na úrovni byte kódu. Žádné skriptovací jazyky, jako například Perl a Python, nejsou uvažovány. Ačkoli mnoho vývojářů může tvrdit přesný opak, nejsou příliš vhodné pro tak velkou aplikaci a psát interpret v interpretovaném jazyce není příliš vhodné.

Obrovskými výhodami Javy je její automatický správce paměti a spousta existujících knihoven a frameworků. Na druhou stranu naprostá většina kompilátorů a interpretů je psaná v C nebo C++ kvůli kompilaci do strojového kódu a z ní vyplývající rychlosti provádění.

Autor při vývoji systémových aplikací preferuje C++ a má s ním také mnohem více zku\-še\-no\-stí, a proto byl tento jazyk zvolen pro implementaci aplikace. Žádná další knihovna, kromě standardního STL, nebude při tvorbě základního kódu použita, interpret pro příkazovou řádku by měl mít co nejméně externích závislostí. Díky tomu by měl být bez větších problémů portovatelný na všechny platformy, pro které existuje C++ kompilátor.

Grafická část aplikace bude naprogramována s použitím knihovny Qt. Je jednou z nejlépe navržených knihoven pro tvorbu GUI aplikací, přenositelná na všechny majoritní operační systémy a bezplatná pro nekomerční použití. Vizualizace grafů budou používat OpenGL, což je standard pro 3D grafiku. Druhá možná volba, Direct3D, není použitelná na ne-Microsoft platformách, a proto je zbytečné o ní uvažovat.


\section{Návrh a specifikace vytvářeného jazyka}

Jak už bylo zmíněno, syntaxe jazyka je z větší části založena na všeobecně známém C, což programátorům přináší výhodu rychlého učení. Jazyk rozlišuje malá a velká písmena, je procedurální a nepodporuje objektově orientované vlastnosti.


\subsection{Datové typy a proměnné}
\label{datove_typy_a_promenne}

Proměnné se nedeklarují a v průběhu vykonávání skriptu mohou libovolně měnit svůj datový typ. Uvnitř interpretu jsou rozlišovány typy \texttt{null}, \texttt{bool}, \texttt{int}, \texttt{float}, \texttt{string}, \texttt{struct}, \texttt{array}, \texttt{graph}, \texttt{vertex}, \texttt{edge}, \texttt{vertexset} a \texttt{edgeset}. Jazyk nepodporuje modifikátory typu, jako jsou například \texttt{unsigned} nebo \texttt{const}, protože nepřinášejí žádné výrazné vylepšení, programátor se bude muset obejít bez nich.

Viditelnost proměnných je definována na úroveň funkcí, tudíž opuštění daného bloku (na\-pří\-klad cyklu) nezpůsobuje zrušení v něm používaných proměnných. Globální pro\-měn\-nou je možné ve funkci zpřístupnit po vzoru jazyka PHP klíčovým slovem \texttt{global}.

\begin{verbatim}
function example()
{
    global g_var;
    g_var = "some value";
}
\end{verbatim}

Při úvahách o deklarací proměnných byly zvažovány celkem čtyři možnosti.

\begin{enumerate}
\item Jako v C, povinná
\item Jako v C, nepovinná
\item Jako v JavaScriptu pomocí \texttt{var jméno;}, nepovinná
\item Bez deklarací
\end{enumerate}

Na první pohled je jasné, že prostřední dvě možnosti nepřinášejí nic užitečného. Pokud jsou deklarace volitelné, nejde těžit z jejich výhod a pouze přidávají nová klíčová slova, což je patrné především u JavaScriptového způsobu.

Výhodou deklarací je snadná detekce chyb a případně možnost větších optimalizací. Na druhou stranu příliš svazují, což je patrné především u skriptovacích jazyků, které se snaží o co nejmenší množství kódu na co největší funkcionalitu. Právě z tohoto důvodu byla zvolena verze bez deklarací.

Poznámka na okraj: Deklarace by se mohly hodit i pro automatizovaný překlad do jiných běžně používaných jazyků, než ve kterém byl napsán vlastní algoritmus. V tomto případě by se pravděpodobně jednalo o kompilovatelné C++ nebo Javu. Tato myšlenka je inspirována Google Web Toolkitem, který překládá javovské programy do HTML, CSS a JavaSkriptu, nejedná se o nic nereálného.


\subsection{Operátory}

Jazyk podporuje prakticky všechny operátory z jazyka C s výjimkou operátoru čárky a bitových operátorů. Priority jsou stejné jako v C.

\begin{itemize}
\item Unární operátory
	\begin{itemize}
	\item \texttt{-}, \texttt{!}, \texttt{++}, \texttt{--}
	\end{itemize}
\item Binární operátory
	\begin{itemize}
	\item Aritmetické: \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{\%}
	\item Přiřazovací: \texttt{=}, \texttt{+=}, \texttt{-=}, \texttt{*=}, \texttt{/=}, \texttt{\%=}
	\item Přiřazení reference: \texttt{\&=}
	\item Logické: \texttt{==}, \texttt{!=}, \texttt{<=}, \texttt{>=}, \texttt{<}, \texttt{>} \texttt{\&\&}, \texttt{||}
	\item Přístup k prvkům: \texttt{.}, \texttt{[]}
	\end{itemize}
\item Ternární operátor
	\begin{itemize}
	\item \texttt{? :}
	\end{itemize}
\end{itemize}


\subsection{Řídící struktury}

Zápis podmínek a cyklů je naprosto stejný jako v C, je možné použít konstrukce \texttt{if}, \texttt{if-else}, \texttt{for} a \texttt{while}. Vícenásobné větvení \texttt{switch} není implementováno, protože je bez problémů nahraditelné vnořenými \texttt{if-else} podmínkami.

Jazyk dále přináší cyklus \texttt{foreach}, který umí iterovat přes všechny prvky složeného datového typu, jimiž jsou například pole a struktury, ale také vlastnosti vrcholů a hran. Cyklus \texttt{foreach} interně používá iterátory.

\begin{verbatim}
foreach(item; iterableObject)
{
    println(item);
}
\end{verbatim}

Předčasné ukončení cyklu je možné provést klasicky pomocí strukturovaných skoků \texttt{break} a \texttt{continue}.


\subsection{Funkce}

Funkce se ve skriptu deklarují podobně jako v jazyce PHP. Klíčové slovo \texttt{function} následuje jméno funkce, v kulatých závorkách čárkami oddělený seznam parametrů a ve složených závorkách tělo funkce. Při parsování nezáleží na pořadí funkcí ve zdrojovém souboru, interpretace začíná až po zpracování celého zdrojového kódu, kdy už jsou všechny dostupné. Samotný skript se spouští funkcí \texttt{main(argv)} s polem argumentů v parametru.

U volání funkcí jsou k dispozici dvě ekvivalentní syntaxe. V první verzi je možné všechny parametry předat klasicky do kulatých závorek, u druhého způsobu je první parametr zapsán tečkovou notací před jméno funkce a celý zápis potom vypadá, jako volání metody nad daným objektem. Forma je inspirována jazykem Python a jeho \texttt{self} parametrem u metod třídy.

\begin{verbatim}
function someFunc(parameter1, parameter2, parameter3)
{
    return "some value";
}

someFunc(object, parameter2, parameter3);
object.someFunc(parameter2, parameter3);
\end{verbatim}

Při návrhu bylo zvažováno také předávání parametrů odkazem, tato technika se používá především k vracení několika hodnot z funkce najednou. Nakonec se ale došlo k závěru, že není vyloženě nutná. Hodnoty je možné uložit do struktury nebo pole a vrátit je ve formě kontejneru. Jednoduchost jazyka a nedeklarativnost proměnných k tomu přímo vybízí.


\subsection{Preprocesor}

Pro vložení zdrojového souboru, například knihovny funkcí, slouží příkaz \texttt{include} s cestou a jménem souboru v parametru. Nové makro je možné specifikovat příkazem \texttt{define}. Kdykoli se ve zdrojovém souboru objeví specifikovaný identifikátor, je automaticky nahrazen hodnotou makra. Obě konstrukce se zpracovávají na úrovni lexikálního analyzátoru a parseru se předává až výsledný proud tokenů.

\begin{verbatim}
include("filename");
define("name", "value");
\end{verbatim}


\subsection{Datové kontejnery}

Základními datovými kontejnery na úrovni jazyka zůstávají pole a struktury, ty se však dají jednoduše rozšířit. Zásobník a fronta se z pole vytvoří definováním operací \texttt{pushFront()}, \texttt{push\-Back()}, \texttt{popFront()}, \texttt{popBack()}, \texttt{front()} a \texttt{back()}. Struktura se dá bez jakýchkoli změn po\-u\-ží\-vat jako mapa (asociativní pole) a množina. S její pomocí se dá jednoduše implementovat i spojový seznam.

Na rozdíl od jiných skriptovacích jazyků není definována speciální syntaxe pro deklarace a vytváření netriviálních typů proměnných. Pro zachování jednoduchosti stačí pouze zavolat zabudované funkce \texttt{array()} a \texttt{struct()}, které vrací nově vytvořený objekt daného datového typu, a ná\-sled\-ně je začít používat.

\begin{verbatim}
arr = array(5);
arr[0] = "item";
arr[1] = array(10);
arr[3] = 3.14;

st = struct();
st.name = "item";
st.valid = true;
\end{verbatim}


\subsection{Grafy, vrcholy a hrany}

První operací při práci s grafovými vlastnostmi jazyka je vždy \texttt{graph()}, zabudovaná funkce pro konstrukci objektu grafu. Je-li vytvořen graf, může se přistoupit k vytváření vrcholů a hran a následně k práci s nimi. Vrcholy a hrany se zároveň chovají i jako struktury, tudíž je u nich možné používat libovolný počet libovolně pojmenovaných vlastností.

\begin{verbatim}
g = graph();

v1 = g.generateVertex();
v2 = g.generateVertex();
e1 = g.generateEdge(v1, v2);

v1.color = "red";
v2.visited = false;
e1.value = 3.14;
neighbors = v1.getNeighbors();

foreach(vert; neighbors)
    doSomething(vert);
\end{verbatim}

Pro vytváření množin vrcholů a hran slouží opět zabudované funkce.


\subsection{Ukázka spustitelného skriptu}

Příkladem kompletního skriptu zapsaného ve vytvářeném jazyce bude rekurzivní pro\-hle\-dá\-vá\-ní grafu do hloubky. Parametrem uživatelsky definované funkce \texttt{dfs()} je libovolný vrchol grafu. Pokud už byl daný vrchol navštíven, větev procházeného stromu se ukončí, v opačném případě se označí vrchol za navštívený a funkce se rekurzivně zavolá nad všemi jeho sousedy.

\begin{verbatim}
define("NEW", "0");
define("CLOSED", "1");

// Recursive depth first search
function dfs(v)
{
    if(v.state == CLOSED)
        return;

    echo("Closing vertex: " + v.num + "\n");
    v.state = CLOSED;

    foreach(neighbor; v.getNeighbors())
        dfs(neighbor);
}
\end{verbatim}


Výše definovaný algoritmus funguje nad všemi orientovanými i neorientovanými spojitými grafy. Od začátku vývoje se předpokládá nahrávání grafů z externích souborů, nicméně jejich vytváření je možné i v kódu programu.

V následujícím výpisu je definován netriviální neorientovaný graf o dynamicky definované velikosti. Každému vrcholu je nastavením vlastnosti \texttt{num} předáno pořadové číslo vytvoření. Následně je stav všech vrcholů inicializován na \texttt{NEW} a spuštěn algoritmus pro procházení do hloubky.

\begin{verbatim}
define("NUM_VERTICES", "10"); // In one layer

function main(argv)
{
    // o --- o --- o --- ...
    // |     |     |
    // o     o     o

    g = graph();
    v1 = g.generateVertex();
    v1.num = 0;
    first = v1;

    // Generate first layer
    for(i = 1; i < NUM_VERTICES; i++)
    {
        v2 = g.generateVertex();
        v2.num = i;

        g.generateEdge(v1, v2);
        v1 = v2;
    }

    // Generate second layer
    foreach(v1; g.getVertices())
    {
        v2 = g.generateVertex();
        v2.num = i++;
        g.generateEdge(v1, v2);
    }

    // Initialize states
    foreach(v; g.getVertices())
        v.state = NEW;

    // Run (any vertex first)
    dfs(first);
}
\end{verbatim}


\section{Analýza reprezentace grafu}

\subsection{Obecné požadavky}

Jedním ze základních kamenů vytvářené aplikace je reprezentace grafů, vrcholů, hran a jejich množin v kódu programu. Přímo ze zadání práce vyplývá několik skutečností, ostatní se dají odvodit, či odhalit prostou logikou. Následuje stručný přehled, který bude dále rozebírán a diskutován.

\begin{itemize}
\item typ podporovaných grafů
\item zapnutí a vypnutí orientace, inverze orientace
\item dynamické grafy, složitost vytváření nových uzlů a hran
\item způsob uložení vlastností uzlů a hran
\item zpětná reference na objekt celého grafu
\item identifikovatelnost sebe sama v grafu
\item přístup k sousedním uzlům
\item přístup k počátečnímu a koncovému uzlu hrany
\item reprezentace množin uzlů a hran, množinové operace
\item iterace přes všechny uzly/hrany grafu/množiny
\item paměťový management, paměťové nároky
\end{itemize}

První a nejdůležitější z otázek se ptá, jakou třídu grafů je třeba podporovat. Jelikož je program psán úplně od začátku a neexistují žádná omezení plynoucí z již existujícího kódu a napojování se na něj, je rozumnou volbou uvažovat maximální množinu všech grafů. Ta zahrnuje orientované i neorientované grafy, spojité i nespojité, několik paralelních hran mezi dvěma uzly a samozřejmě také smyčky nad uzlem -- tj. hrana začíná i končí ve stejném vrcholu. Dále v textu bude vidět, že toto rozhodnotí silně omezí možné způsoby implementace, popř. je výrazně zesložití.

Ačkoli se předpokládají spíše statické grafy, které se na začátku vytvoří a dále se už měnit nebudou, přidávání a mazání nových uzlů a hran by mělo být \textit{rozumně} složité a netrvat věčnost. Kopírovat celou matici sousednosti o milionu prvků kvůli jednomu přidanému uzlu rozhodně nebude správnou cestou.

Zadání práce požaduje, aby vrcholy i hrany mohly být nějakým, nespecifikovaným, způsobem ohodnoceny. Opět bude vhodné uvažovat, kvůli obecnosti řešení, maximalistickou variantu. Budeme předpokládat, že každá z hran i vrcholů může být ohodnocena libovolným počtem vlastností libovolného typu. Z tohoto rozhodnutí plyne, že by vrchol i hrana měly mít svou vlastní třídu (ve významu objektového programování), aby se s nimi dalo jednodušeji manipulovat.

Jelikož budou vrcholy a hrany v interpretu zpřístupnitelné i jako samostatné proměnné, je třeba, aby si nějakým způsobem pamatovaly, ke kterému grafu patří. Tento požadavek bude nejspíše řešen uložením ukazatele na objekt grafu do atributu třídy. Vrcholy i hrany by dále měly být v grafu schopné identifikovat sebe sama. Pokud by byl graf implementován například maticí sousednosti, je tento požadavek naprosto zásadní, protože bez něj by například nebylo možné najít sousedy daného uzlu.

Další z důležitých otázek je reprezentace množin uzlů a hran, přidávání a odebírání prvků, množinové a jiné operace. Výhodou bude, když budou množiny reprezentované identicky jako celý graf, protože spousta kódu potom zůstane ekvivalentní. Předpokládá se časté přidávání a odebírání prvků, a proto by měly být tyto operace jednoduché a rychlé.

Předpokládaná velikost grafů jsou miliony vrcholů a hran, čímž vznikají ob\-rov\-ské pa\-mě\-ťo\-vé nároky. Každé z primitiv může být odkazováno proměnnou v interpretu, či jiného místa, a proto bude pravděpodobně potřeba nějaký druh paměťového managementu, který zamezí chybám při práci s dynamickou pamětí.


\subsection{Reprezentace grafu}

Existuje několik možností, jak reprezentovat graf v programu. V teorii grafů bývají nejčastěji zmi\-ňo\-vá\-ny maticové reprezentace a spojové seznamy, ale existují i další, méně obvyklé, způsoby.

\begin{itemize}
\item matice inicidence $|U| \times |H|$
\item matice sousednosti $|U| \times |U|$
\item spojové seznamy -- seznam následníků apod.
\item jiné reprezentace
\end{itemize}

Cílem této části bude najít nejvhodnější reprezentaci grafu, kterou by bylo možné použít ve specifické oblasti interpretu.


\subsubsection{Standardní maticové reprezentace}

Matice sousednosti je v grafové teorii definována jako dvourozměrné pole $|U| \times |U|$. V jazyce C++ s použitím knihovny STL by mohly být atributy třídy grafu definovány například následovně.

\begin{verbatim}
class Graph
{
    vector<Vertex*> m_vertices;
    vector< vector<Edge*> > m_edges;
};
\end{verbatim}

Parametry datových kontejnerů nemohou být primitivní datové typy, protože každý vrchol i hrana musí umět ukládat dodatečné vlastnosti typu klíč--hodnota definované v požadavcích na systém.

Na první pohled se zdá, že by mohlo být výhodné použít tuto reprezentaci, nicméně existuje několik výrazných problémů. Největším z nich jsou paralelní hrany, protože počáteční a koncový vrchol hranu neurčují jednoznačně. Řešením by mohla být trojrozměrná matice a trojrozměrné indexy, je však vidět, že toto řešení rozhodně není hezké.

\begin{verbatim}
    vector< vector< vector<Edge*> > > m_edges;
\end{verbatim}

Další velkou nevýhodou je příliš složité přidávání a mazání vrcholů a vyplývající časté realokace velkých bloků paměti. Toto řešení by tedy bylo vhodné spíše pro statické grafy, které se na začátku vytvoří a pak zůstanou nezměněny až do konce algoritmu.

Problémem je i složité procházení vrcholů a hran a hledání sebe sama v grafu. Každý vrchol a hrana musí mít u sebe uložen index do matice reprezentující graf, který se navíc může při přidání nového vrcholu u všech již existujících vrcholů posunout. Tímto by se výrazně zvýšily paměťové i výpočetní nároky.

Další problémy pravděpodobně vzniknou při vytváření množin vrcholů a hran, které budou mít naprosto odlišnou implementaci vzhledem k vlastní třídě grafu. Paměťový management by býl extrémně složitý a náchylný k chybám.

Výše uvedená diskuze odhalila množství nepřekonatelných problémů, které by vznikly při použití matice sousednosti. Dá se také předpokládat, že se úplně stejné problémy objeví i u matice inicidence a všude tam, kde je vlastní struktura grafu, návaznost vrcholů a hran, definovaná centrálně ve třídě grafu.


\subsubsection{Reprezentace množinami vrcholů a hran}
\label{reprezentace_mnozinami_vrcholu_a_hran}

Tato reprezentace grafů se ve školách neučí, ale v tomto konkrétním specifickém případě, intepretu, je velice elegantní. Samotný nápad vznikl při odhalení slepé uličky u maticových reprezentací, které strukturu grafu definují centrálně v jedné datové struktuře. Bylo potřeba najít nějaké distribuované řešení.

Datové položky grafu budou tvořit pouze dvě množiny vrcholů a hran. Na tomto místě by se dal použít i jiný datový kontejner, avšak množiny se objeví i v jiných třídách a tam už budou nutné. Dá se říci, že ani tyto dva kontejnery ukazatelů by nemusely být ve třídě grafu definovány, nicméně je třeba nějakým způsobem uvolňovat dynamickou paměť, uložení pointerů je proto nezbytné.

\begin{verbatim}
class Graph
{
    set<Vertex*> m_vertices;
    set<Edge*> m_edges;
};
\end{verbatim}

Vlastní struktura grafu, čili propojení vrcholů hranami, je definovaná ne ve třídě grafu, ale přímo ve třídách vrcholů a hran. Vrchol obsahuje množinu hran, které s ním incidují a hrany ukládají ukazatele na svůj počáteční a koncový uzel. Referenci na graf je nutné uchovávat kvůli interpretu.

\begin{verbatim}
class Vertex
{
    Graph* m_graph;
    set<Edge*> m_edges;
};

class Edge
{
    Graph*  m_graph;
    Vertex* m_begin
    Vertex* m_end;
};
\end{verbatim}

Hlavní výhodou této reprezentace je možnost práce s naprosto obecným grafem, nemusíme se starat o paralelní hrany ani smyčky nad uzly. Už bylo zmíněno, že druhý typ reprezentace, matice sousednosti, ve své standardní verzi neumí pracovat s paralelními hranami.

Druhou obrovskou výhodou je ekvivalentní implementace grafu a množin jeho uzlů a hran. Není nutné programovat identické operace dvakrát a poté je navíc složitě napojovat na sebe. Výhodou je i přirozená a jednoduchá iterovatelnost množin, díky níž nebude složité implementovat procházení grafu pomocí cyklu \texttt{foreach}.

Jedinou možnou nevýhodou je mírná duplicita informací při definici struktury gra\-fu, která je podobná obousměrně propojenému spojovému seznamu. Průchod je možný od uzlů k hranám a také naopak od hran k uzlům. V rozhraní tříd bude nutné ošetřit, aby kvůli této duplicitě nemohly vzniknout žádné problémy.


\subsubsection{Testovací implementace}

V následujícím výpisu kódu je ukázána až překvapivá elegance řešení na bázi množin vrcholů a hran ve spojení se standardní knihovnou STL a její šablonou \texttt{set}. Jsou ukázány čtyři funkce třídy grafu, které se starají o vytváření a mazání vrcholů a hran. Zdají natolik jednoduché, že veškeré komentáře jsou asi zbytečné.

\begin{verbatim}
Vertex* Graph::generateVertex(void)
{
    Vertex* vertex = new Vertex(this);
    m_vertices.insert(vertex);
    return vertex;
}

Edge* Graph::generateEdge(Vertex* begin, Vertex* end)
{
    Edge* edge = new Edge(this, begin, end);
    m_edges.insert(edge);

    begin->addEdge(edge);
    end->addEdge(edge);

    return edge;
}

void Graph::deleteVertex(Vertex* vertex)
{
    set<Edge*>& edges = vertex->getEdges();

    set<Edge*>::iterator it;
    for(it = edges.begin(); it != edges.end(); it++)
        deleteEdge(*it);

    m_vertices.erase(vertex);
    delete vertex;
}

void Graph::deleteEdge(Edge* edge)
{
    edge->getBeginVertex()->deleteEdge(edge);
    edge->getEndVertex()->deleteEdge(edge);
    m_edges.erase(edge);
    delete edge;
}
\end{verbatim}

Výhradně tyto čtyři funkce pracují s pamětí, a tudíž je možnost jejích úniků v této části aplikace vyloučená.

Implementace podmnožin vrcholů a hran je téměř identická jako implementace vlastního grafu. Jediný rozdíl se nachází v těchto čtyřech metodách, které u podmnožin nepracují s pamětí, ale pouze se starají o ukládání a vracení již existujících ukazatelů na objekty.

Přiřazování mezi proměnnými v interpretu není třeba nějak speciálně ošetřovat. Pokud je proměnná \texttt{vertex} vrcholem grafu, pak jeho přiřazení do jiné proměnné nevytváří v původním grafu ani v žádném jiném nový vrchol, nejde o hlubokou kopii. Protože žádný vrchol nemůže bez grafu existovat, je jasné, že proměnná \texttt{alias} z příkladu musí být identická k původnímu vrcholu. Stejnou úvahu lze provést i pro hrany.

\begin{verbatim}
vertex = g.generateVertex();
alias = vertex;
\end{verbatim}

Výše uvedený kód může vypadat jako nežádoucí a jeho použití okrajové, ale naprosto stejné operace se provádějí při předávání parametrů funkcím, a proto je dobré mít ověřeno, že při jejich volání nenastanou žádné problémy. Jak už bylo řečeno, o veškerou dynamicky alokovanou paměť grafu se stará třída \texttt{Graf} a nikdo jiný. Díky mělkým kopiím objektů není tudíž třeba ani garbage collectoru, ani chytrých ukazatelů s počítáním referencí.


\section{Proměnné ve skriptu, typy a operace}

\subsection{Implementace operací větvením}

Existují v zásadě dvě možnosti, jak implementovat sčítání, odčítání a ostatní operace nad hodnotami a proměnnými ve skriptu. První z nich předpokládá použití \texttt{unionu} a pomocné proměnné, která ukládá datový typ uložené hodnoty. Příkladem budiž ukázka z autorova dřívějšího interpretu \cite[třída \texttt{CNodeValue}]{borsch}.

\begin{verbatim}
class CNodeValue
{
private:
    TYPE m_type;

    union
    {
        bool m_b;
        int m_i;
        float m_f;
    };
};
\end{verbatim}

Toto řešení je funkční, nicméně při více podporovaných datových typech a operacích začíná být extrémně nepřehledné a náchylné k chybám. Každá z funkcí implementujících například některou aritmetickou operaci musí obsahovat větvení podle typu, navíc, v případě binární operace, vnořené.

\begin{verbatim}
const CNodeValue CNodeValue::operator+(const CNodeValue& object) const
{
    // ...

    switch(m_type)
    {
    case LEX_BOOL:
        switch(object.m_type)
        {
        case LEX_BOOL:
            return CNodeValue(m_b + object.m_b);
        case LEX_INT:
            return CNodeValue(m_b + object.m_i);
        case LEX_FLOAT:
            return CNodeValue(m_b + object.m_f);
        default:
            assert(false);
            return *this;
        }

        // ...
    }
}
\end{verbatim}

Tento kód ošetřuje sčítání boolean hodnoty s druhou boolean hodnotou, celým číslem a desetinným číslem. Jedná se pouze o část funkce, v případě tří různých datových typů by funkce obsahovala tři podobné sekce, ve výsledku devět, respektive šestnáct, podmínek.

Navrhovaný jazyk předpokládá dvanáct různých datových typů (viz sekce \ref{datove_typy_a_promenne} na straně \pageref{datove_typy_a_promenne}), což pouze pro sčítání dává celkem 144 větvení! Psát a poté udržovat podobný kód pro všechny operace je naprosto nereálné. Navíc přidání nového datového typu způsobí nutnost slo\-ži\-tých úprav všech existujících funkcí.


\subsection{Double dispatching pattern}
\label{double_dispatching_pattern}

Odpovědí na všechny výše uvedené problémy je návrhový vzor \textit{Multiple dispatching} \cite[str. 679]{eckel}, který poskytuje možnost volání typových operací nad kombinací beztypových objektů. Základem je abstraktní třída \texttt{Value}, která deklaruje všechny potřebné operace -- pro každý datový typ a operaci jedna virtuální metoda, plus jedna čistě virtuální metoda pro neznámý datový typ.

\begin{verbatim}
class Value
{
    // +
    virtual PTR_Value add(const Value&     right) const = 0;
    virtual PTR_Value add(const ValueBool&  left) const;
    virtual PTR_Value add(const ValueInt&   left) const;
    virtual PTR_Value add(const ValueFloat& left) const;
    // ...
};
\end{verbatim}

Sčítání celého čísla s ostatními datovými typy může vypadat následovně. Nejdříve je nutné definovat sčítání celého čísla s neznámým datovým typem na pravé straně. V takovém případě funkce neví, jak tuto operaci provést, a proto požádá tento neznámý typ o sečtení se sebou samým, s tím, že mu oznámí, že se jedná o sčítání s celým číslem (typ ukazatele \texttt{this} je zde \texttt{ValueInt}).

Dejme tomu, že se jednalo také o celé číslo, zavolala se tedy třetí z uvedených metod a provedlo se sečtení celých čísel, jehož výsledkem je taktéž celé číslo. V tuto chvíli byly již všechny potřebné datové typy známé a operace se mohla vykonat.

\begin{verbatim}
PTR_Value ValueInt::add(const Value& right) const
{
    return right.add(*this);
}

PTR_Value ValueInt::add(const ValueBool& left) const
{
    return PTR_Value(new ValueInt(left.getVal() + m_val));
}

PTR_Value ValueInt::add(const ValueInt& left) const
{
    return PTR_Value(new ValueInt(left.getVal() + m_val));
}

PTR_Value ValueInt::add(const ValueFloat& left) const
{
    return PTR_Value(new ValueFloat(left.getVal() + m_val));
}
\end{verbatim}

Jednou z výhod Double dispatching patternu je také to, že není nutné definovat všechny metody pro všechny kombinace datových typů. Pokud operace s danými parametry nedává smysl, například sčítání čísla s vrcholem grafu, ponechá se vykonání operace na rodičovské třídě \texttt{Value}, jež může kupříkladu vypsat chybu a vrátit \texttt{null} hodnotu.

\begin{verbatim}
PTR_Value Value::add(const ValueGraph& /* left */) const
{
    cerr << "Operation is not supported" << endl;
    return VALUENULL;
}
\end{verbatim}

V případě přidání nového datového typu se žádná z již existujících funkcí nemění, pouze se do základní třídy dopíše nová virtuální operace a do potomků, kde to dává smysl, její implementace.


\section{Reprezentace skriptu a vykonávání}

\subsection{Abstraktní strom syntaxe}
\label{abstraktni_strom_syntaxe}

Zdrojové soubory skriptu se překládají pomocí lexikálního analyzátoru a parseru do vnitřní reprezentace. Jejím základním prvkem je abstraktní třída \texttt{Node}, ze které budou odvozené všechny ostatní, například třída pro větvení, třída pro cykly a další.

Posláním parseru je sestavit \textit{abstraktní strom syntaxe}, který bude následně použit pro vykonávání programu. Povinností stavebních kamenů je definovat metodu \texttt{execute()}, jež se bude při vykonávání volat rekurzivně na všech úrovních stromu.

\begin{verbatim}
class Node
{
public:
    virtual CountPtr<Value> execute(void) = 0;
};
\end{verbatim}

Kontext skriptu, ve kterém jsou uložené například hodnoty proměnných bude definován v externí třídě, pravděpodobně singletonu. Druhou možností by bylo předávat kontext metodám v parametru, ale to bylo v současnosti označeno za zbytečné plýtvání výkonem, nepředpokládají se vícevláknové skripty.

Alternativní možností vykonávání skriptu by mohl být překlad do instrukcí virtuálního procesoru a jejich interpretace, nicméně to se aktuálně jeví jako zbytečně náročné řešení, které by nepřineslo téměř nic navíc.

Pozice ve zdrojových kódech bude uchovávána ne ve všech, ale pouze ve speciálních uzlech stromu. Například příkazy budou obaleny objekty typu \texttt{NodePosition}, jejichž prací bude aktualizovat pozici v kontextu a rekurzivní zavolání metody svého následníka. Tato technika umožní, aby pozice nemusela být zbytečně uchovávána v každém prvku stromu.


\subsection{Podpora debuggingu}

Výhodou lineárního pole instrukcí a virtuálního procesoru je snadná implementace debuggingu. V kterémkoli okamžiku je možné pozastavit vykonávání, protože kód skriptu je uložen výhradně v datové struktuře. Po případném opuštění interpretující funkce zůstane stav virtuálního procesoru zachován a pozastavený skript může být kdykoli opětovně spuštěn.

Naproti tomu, při použití abstraktního stromu syntaxe, je kód reprezentován především datovými typy uzlů. Vykonávání spočívá v rekurzivním volání jedné funkce, kteréžto není možné přerušit a na daném místě později pokračovat. Vzniká otázka, jak pozastavit toto rekurzivní vykonávání.

Odpovědí je \textit{vícevláknové programování} a jeho synchronizační prostředky. V případě řádkové utility se debugging nepředpokládá, u grafického rozhraní je další vlákno pro vykonávání skriptu naopak nezbytné. Bez něj by aplikace po spuštění interpretu nemohla reagovat na žádné požadavky a uživateli by se jevila jako zamrzlá.

Princip pozastavení skriptu demonstruje následující výpis kódu, používající synchronizační prostředky knihovny Qt. Pokud skript narazí například na breakpoint, zavolá funkci \texttt{pause()}, jež ve \texttt{wait()} čeká na signál k opětovnému spuštění. Tento příkaz vydává hlavní vlákno aplikace kupříkladu po kliknutí uživatele na tlačítko \textit{Pokračovat}.

\begin{verbatim}
QMutex dbgMutex;
QWaitCondition waitCondition;

// Script thread (ie. breakpoint)
void pause(void)
{
    dbgMutex.lock();
    waitCondition.wait(&dbgMutex);
    dbgMutex.unlock();
}

// Main/GUI thread (ie. click on next line button)
void resume(void)
{
    waitCondition.wakeAll();
}
\end{verbatim}

Ač se to nemusí zdát, je výše uvedené řešení plně funkční. Bylo implementováno v jednoduché testovací aplikaci a pracuje bez jediného problému.


\subsection{Úniky paměti, správce paměti}

V kapitole \ref{abstraktni_strom_syntaxe} na straně \pageref{abstraktni_strom_syntaxe} byla představena virtuální funkce \texttt{execute()}, jejíž rekurzivní volání umožňuje interpretaci skriptu. Jednou ze zcela zásadních věcí je její návratová hodnota, která slouží především pro získání výsledku aritmetických výrazů.

Mějmě například následující jednoduchý skript, jehož úkolem je sečíst dvě čísla.

\begin{verbatim}
function main(argv)
{
    return 1 + 2;
}
\end{verbatim}

Součet bude v syntaktickém stromu uložen celkem ve třech uzlech. Listy vracejí svoji hodnotu ve formě celých čísel, binární operátor následně tyto dvě hodnoty sečte a vrátí výsledek operátoru return. Vykonávání pokračuje v podobném duchu až do dosažení kořene stromu.

Je jasné, že třída pro sčítání nezná datový typ návratové hodnoty při kompilaci, může jím být například \texttt{null}, \texttt{int}, \texttt{float} aj., a tudíž návratovou hodnotou funkce musí být abstraktní objekt typu \texttt{Value} představený v sekci \ref{double_dispatching_pattern} na straně \pageref{double_dispatching_pattern}.

Z toho dále vyplývá, že se musí objekty vytvářet dynamicky a s tím souvisí velice častý problém programátorů v jazycích C a C++: \textit{Kdy je možné tyto objekty smazat a kdo se o to postará}.


\subsubsection{Garbage collector}

Jednou z možností je naprogramovat a poté používat \textit{Garbage collector} obdobný javovskému. Velkou výhodou by bylo vyřešení naprosto všech, současných i budoucích, problémů s u\-vol\-ňo\-vá\-ním dynamické paměti. Nevýhodou složitá implementace a dodatečná režie při vykonávání. V případě použití nějakého již existujícího garbage collectoru vzniká závislost na externí knihovně a s tím souvisí i nižší či složitější přenositelnost programu.

V tomto případě se zdá, že nevýhody převažují nad výhodami. Navíc se přece jedná o ná\-vra\-to\-vou hodnotu \textit{výhradně} jedné funkce, možná by stačilo zapouzdřit ukazatel na návratovou hodnotu do další třídy, která by se následně postarala o smazání.


\subsubsection{Chytré ukazatele}

Nejjednodužší implementací chytrých ukazatelů je šablona \texttt{auto\_ptr} ze standardní kni\-hov\-ny. Bude stačit nebo bude potřeba silnější nástroj? Po požádání se \texttt{auto\_ptr} stává výhradním vlastníkem ukazatele a při své destrukci smaže i předanou dynamickou paměť. Výhradní vlastník znamená, že v jednom okamžiku může existovat právě jedna \texttt{auto\_ptr} reference, na danou paměť.

Splnit tento požadavek bohužel nelze. Chceme-li například vrátit hodnotu uloženou v pro\-měn\-né interpretovaného skriptu, první referencí bude původní proměnná a druhou vracená hodnota. Musíme tedy hledat silnější nástroj.

Pokud je jediným problémem \texttt{auto\_ptr} pouze možný větší počet odkazů, můžeme použít chytrý ukazatel na bázi čítání referencí \cite{smartp}. Ten zapouzdřuje ukazatel na dynamický objekt spolu s čítačem referencí, který se při vytvoření objektu nastaví na jedna a při každém zavolání kopíravacího konstruktoru nebo operátoru přiřazení inkrementuje. V destruktoru se naopak počet referencí dekrementuje a při dosažení nulové hodnoty se objekt smaže.

Toto řešení by mohlo fungovat, jen je třeba si dát pozor na cyklické reference, kdy první objekt odkazuje na druhý a zároveň druhý objekt odkazuje na první, paměť by se nikdy neuvolnila. Tato situace bohužel může v interpretu nastat, protože právě tímto způsobem je uložena struktura grafu (viz kapitola \ref{reprezentace_mnozinami_vrcholu_a_hran} na straně \pageref{reprezentace_mnozinami_vrcholu_a_hran}). Vrcholy obsahují seznam incidujících hran a hrany odkaz na počáteční a koncový uzel.

Z toho plyne, že pokud nebude na tomto konkrétním místě chytrý ukazatel s čítáním referencí použit, což není žádné zásadní omezení, bude efektivním řešením problému návratové hodnoty \texttt{execute()}.


\section{Grafické uživatelské rozhraní}

Grafické uživatelské rozhraní bude naprogramováno s použitím knihovny Qt. Sestává z hlav\-ní\-ho okna aplikace \texttt{QMainWindow}, jehož centrálním widgetem bude textový editor pro programátory na bázi \texttt{QPlainTextEdit}. Jedná se o MDI aplikaci, jednotlivé editory je možné přepínat, po vzoru webových prohlížečů, pomocí panelů či listů. Menu, nástrojová lišta a stavový řádek jsou pro daný typ aplikace samozřejmostí.

Knihovna Qt poskytuje možnost vkládat do okrajů hlavního okna plovoucí panely, objekty třídy \texttt{QDockWidget}, jež mohou být přesunuty na jiné místo a také \textit{vytrhnuty} do samostatného okna. Tato funkcionalita se určitě hodí u vizualizací, v případě jednoho monitoru budou panelem v hlavním okně aplikace, zároveň však existuje možnost zobrazit ho i v samostatném okně na druhém monitoru.

Panelů může být definováno libovolné množství, pro začátek se kromě vizualizací před\-po\-klá\-dá i zobrazování výstupu z vykonávaného skriptu, seznam definovaných proměnných spolu s jejich hodnotami a zásobník volání funkcí.


\section{Shrnutí}

V této kapitole byly definovány základní myšlenky a rozhodnutí pro tvorbu interpretu spe\-ci\-ál\-ní\-ho programovacího jazyka pro manipulaci s grafy. Aplikace bude naprogramována v C++ s využitím standardní knihovny STL, grafická část v Qt a OpenGL.

Analýza odhalila nemožnost reprezentovat graf maticí sousednosti ani jinými technikami, ve kterých je struktura grafu uložena centrálně. Navržené řešení spočívá v obecných množinách uzlů a hran, kde si uzly udržují seznam incidujících hran a hrany odkazy na svůj počáteční a koncový uzel. Díky této technice může být podporován libovolný typ grafů bez jakéhokoli omezení a hlavně s rozumnými složitostmi vykonávání všech operací.

Hodnoty a proměnné ve skriptu budou implementovány pomocí hierarchie tříd, jednotlivé operace budou pracovat na bázi návrhového vzoru Double dispatching.

Skript bude v interpretu reprezentován abstraktním stromem syntaxe. Jeho vykonávání spočívá v rekurzivním volání metody \texttt{execute()} nad každým uzlem tohoto stromu. Ná\-vra\-to\-vou hodnotou bude chytrý ukazatel na bázi čítání referencí zapouzdřující obecnou hodnotu. Skript může být v případě debuggingu pozastaven technikami ví\-ce\-vlák\-no\-vé\-ho programování.

Grafické uživatelské rozhraní bude zahrnovat hlavní okno s textovým editorem pro programátory a několika speciálními plovoucí panely, které mohou být uživatelem vytrnuty do samostatného okna.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Realizace}

% TODO: delete
% Popis implementace / realizace se zaměřením na nestandardní části řešení.

\section{Základní kód a interpret pro příkazovou řádku}

\subsection{Hierarchie tříd, třída BaseObject}

V objektově orientovaném návrhu aplikace je vždy dobré vytvořit kořen hierarchie tříd, který bude poskytovat, či pouze definovat, základní obecné operace nad všemi používanými objekty. V jazyce Java se taková třída jmenuje \texttt{Object}, knihovna Qt zavádí \texttt{QObject}, vyvíjená aplikace použije jméno \texttt{BaseObject}.


\subsubsection{Výpis struktury objektů, metoda dump()}

\texttt{BaseObject} v první řadě definuje čistě virtuální metodu, díky níž bude v budoucnosti snazší hledat případné chyby při skládání objektů. Využití se předpokládá především při stavbě a ověřování abstrakního stromu syntaxe skriptu, metoda umožní jeho přehledný výpis.

\begin{verbatim}
virtual void dump(ostream& os, uint indent) const = 0;
\end{verbatim}

Pokud každá třída definuje svoji metodu \texttt{dump()} -- a ony ji definovat musí, protože je čistě virtuální -- může do předaného proudu vypsat informace o sobě a o objektech, které v sobě uchovává. Parametr \texttt{indent} slouží pro odsazování řádků a zpřehlednění výpisu. Mějme například jednoduchý demonstrační skript.

\begin{verbatim}
function main(argv)
{
    value = 1 + 2 * 3;
}
\end{verbatim}

Po přeložení zdrojových kódů do vnitřní reprezentace a zavolání výpisu bude struktura objektů vypadat následovně.

\begin{verbatim}
    <Function name="main" id="63">
        <Parameter name="argv" id="64" />
        <NodeBinaryAss>
            <ValueIdentifier name="value" id="65">
                <NoValue />
            </ValueIdentifier>
            <NodeBinaryAdd>
                <ValueInt value="1" />
                <NodeBinaryMult>
                    <ValueInt value="2" />
                    <ValueInt value="3" />
                </NodeBinaryMult>
            </NodeBinaryAdd>
        </NodeBinaryAss>
    </Function>
\end{verbatim}

XML formát výstupu samozřejmě není nutný, byl použit pouze kvůli své pře\-hled\-nos\-ti.


\subsubsection{Kontrola úniků paměti}
\label{kontrola_uniku_pameti}

Druhou funkcionalitou poskytovanou základní třídou \texttt{BaseObject} jsou testy na úniky dynamické paměti. Jedná se pouze o rychlé ověření, zda změny provedené při vývoji nezpůsobily nějaký problém, a proto záměrně není implementace nijak složitá.

Třída definuje statické úložiště adres alokovaných objektů. Při své konstrukci do něj vloží ukazatel na právě vytvořený objekt, v destruktoru ho smaže, toť vše. Jelikož se jedná o kořen hierarchie tříd, tento konstruktor se z definice volá u naprosto všech objektů.

\begin{verbatim}
BaseObject::BaseObject(void)
{
    m_allocated_objects.insert(this);
}

BaseObject::~BaseObject(void)
{
    m_allocated_objects.erase(this);
}
\end{verbatim}

Těsně před ukončením funkce \texttt{main()} se zjistí aktuální počet alokovaných objektů. Pokud není nulový (nutné brát v úvahu i staticky definované objekty), je jasné, že se někde v aplikaci objevil memory leak a tato skutečnost je signalizována vývojáři. Díky RTTI, které jazyk C++ podporuje operátorem \texttt{typeid}, je možné získat i datový typ neuvolněných objektů.

Kód pro testy může způsobovat výrazné zpomalení běhu aplikace, a proto byl obalen do podmíněné sekce preprocesoru \texttt{CHECK\_MEMORY\_LEAKS}, jež je zapnutá pouze při \texttt{debug} kompilaci. Ve výsledné verzi samozřejmě nejsou testy potřeba.

Pozorný čtenář si pravděpodobně uvědomil, že nejsou kontrolovány pouze dynamické, ale i statické alokace. Možná by stálo za úvahu vložit kód do přetížených operátorů \texttt{new} a \texttt{delete}, nicméně statické objekty jsou uvolněny vždy, a proto nemají žádný vliv na správnost zjištěné informace.


\subsubsection{Pořadí inicializace statických objektů}

Učebnice jazyka C++ se pouze velice zřídka věnují tématu \textit{pořadí inicializace statických objektů} (v angličtině Static object initialization order), jednou z mála výjimek je \cite{industrial_strength_cpp}. Jedná se o situaci, kdy linker při spojování jednotlivých modulů může způsobit zásadí nefunkčnost naprosto správného kódu!

Termín \textit{statický objekt} je zde používán ve významu atributu třídy deklarovaného s modifikátorem \texttt{static}, jenž způsobí sdílení mezi všemi objekty dané třídy. Druhým problémovým typem mohou teoreticky být i globálně deklarované proměnné, to však autor práce nemá nijak ověřeno. Jako praktickou ukázku nastavší chyby můžeme použít statickou proměnnou \texttt{BaseObject::m\_allocated\_objects} z kapitoly \ref{kontrola_uniku_pameti} na straně \pageref{kontrola_uniku_pameti}.

Statický objekt je vytvářen a inicializovanám ještě před vlastním spuštěním funkce \texttt{main()}. Jazyk C++ pro inicializaci používá speciální konstrukci zapsanou vně všech funkcí a tříd.

\begin{verbatim}
class BaseObject
{
private:
    static set<BaseObject*> m_allocated_objects;
};

set<BaseObject*> BaseObject::m_allocated_objects;
\end{verbatim}

Definujme ještě jednu třídu, singleton poděděný od \texttt{BaseObject}, jež bude v sobě obsahovat taktéž statický objekt.

\begin{verbatim}
class Singleton : public BaseObject
{
private:
    static Singleton m_instance;
};

Singleton Singleton::m_instance;
\end{verbatim}

A nyní přichází otázka: Bude \texttt{BaseObject::m\_allocated\_objects} inicializováno dříve než \texttt{Singleton::m\_instance}, či naopak? Jedná se o zásadní otázku, protože \texttt{Singleton} dědí od \texttt{BaseObject} a pracuje s \texttt{m\_allocated\_objects}, které v tuto chvíli ještě nemusí existovat.

Vše tedy závisí na linkeru, nevhodné pořadí spojování modulů může způsobit pád aplikace ještě před vlastním spuštěním funkce \texttt{main()} -- \textit{neoprávněný přístup do paměti}.

Pokud nejde použití statických objektů v aplikaci zamezit nebo je jiné řešení silně nepraktické, existuje proti chybě relativně snadná obrana. Stačí založit nový soubor se zdrojovými kódy a do něj přesunout naprosto všechny statické inicializace. Jazyk C++ garantuje pořadí inicializace objektů v rámci jednotlivých modulů. Nahoru je tedy třeba zapsat ty, jenž se musejí provést nejdříve, a dolů ty, které na nich závisí. V naší demonstraci by obsah souboru vypadal následovně.

\begin{verbatim}
set<BaseObject*> BaseObject::m_allocated_objects;
Singleton Singleton::m_instance;
\end{verbatim}

Je pravda, že výše uvedená ukázka je k chybě výrazně náchylnější než běžná použití statických objektů, nicméně autor se již v minulosti setkal s podobným problémem, který ovšem nezpůsoboval tak zásadní nefunkčnost. V obou případech se navíc jednalo o dva různé kompilátory -- Microsoft Visual Studio 2005 oproti GNU gcc.


\subsection{Hodnoty a proměnné ve skriptu, Value* hierarchie tříd}

Jak už bylo zmíněno v kapitole \ref{double_dispatching_pattern} analýzy na straně \pageref{double_dispatching_pattern}, binární operace nad hodnotami ve skriptu jsou vykonávány s využitím návrhového vzoru Double dispatching.

Kořenem hierarchie je abstraktní třída \texttt{Value}, potomci se jmenují \texttt{ValueNull}, \texttt{Va\-lue\-Bool}, \texttt{ValueInt}, \texttt{ValueFloat} atd., každá ze zavedených tříd může být použita v libovolné operaci. Hodnota \texttt{null}, respektive \texttt{false} u logických operátorů, je vrácena v případě, kdy není operace nad danou kombinací typů definována.

% \begin{enumerate}
% \item aritmetické sčítání \texttt{+}, odčítání \texttt{-}, násobení \texttt{*}, dělení \texttt{/}, dělení modulo \texttt{\%}
% \item logická ekvivalence \texttt{==}, nonekvivalence \texttt{!=}
% \item logické menší nebo rovno \texttt{<=}, větší nebo rovno \texttt{>=}, menší \texttt{<}, větší \texttt{>}
% \item logické AND \texttt{\&\&} a logické OR \texttt{||}
% \item přístup k prvkům struktury \texttt{.}, přístup k prvkům pole \texttt{[]}
% \item unární negace \texttt{!}, unární mínus \texttt{-}
% \end{enumerate}

% Třída \texttt{Value} dále definuje metodu \texttt{toBool()}, jež umožňuje přetypování libovolného objektu na logickou hodnotu, využívána je především operátory AND a OR. Metoda \texttt{isNull()} slouží pro dotaz, zda se jedná o \textit{plnohodnotný} typ, či o \texttt{ValueNull} hodnotu. Konverzi na textovou reprezentaci zapouzdřené hodnoty je možné provést zavoláním metody \texttt{toString()}.

K dotazu, zda je možné do objektu přiřadit jinou hodnotu, poslouží metoda \texttt{isLValue()}. Vlastní přiřazení je následně možné provést pomocí funkcí \texttt{assign()} a \texttt{assignRef()} -- detaily viz kapitola \ref{valuereference_a_prirazovani_do_promennych} na straně \pageref{valuereference_a_prirazovani_do_promennych}.

Iterování přes prvky složených datových typů je podporováno čtyřmi metodami \texttt{iterator()}, \texttt{hasNext()}, \texttt{next()} a \texttt{resetIterator()}. Jednoduché datové typy nejsou iterovatelné, a proto jakékoli pokusy o procházení hned na začátku odmítnou.

Potomci, především grafové třídy, definují i další specifické metody. Ke konverzi z obecného \texttt{Value} ukazatele na konkrétní datový typ slouží skupina virtuálních funkcí \texttt{toValueBool()}, \texttt{toValueInt()} atd., které vracejí \texttt{NULL}, pokud se nejedná o daný datový typ. Použití leží především v zabudovaných funkcích interpretu, které v parametru předpokládají konkrétní datový typ a volají jeho specifické operace. Na tomto místě by šlo samozřejmě použít i RTTI přetypování \texttt{dynamic\_cast}, obě techniky jsou ekvivalentní.


\subsubsection{ValueNull a ValueBool}

Obě tyto třídy jsou definovány jako singleton a v kódu mohou být používány pomocí zkrá\-ce\-né\-ho zápisu \texttt{VALUENULL}, \texttt{VALUEBOOL\_TRUE} a \texttt{VALUEBOOL\_FALSE}. Jedná se o makro, které volá statickou metodu \texttt{getInstance()}.

Implementace pomocí singletonu byla zvolena z důvodu, aby nebylo nutné neustále vytvářet nové a nové ekvivalentní objekty.


\subsubsection{Přiřazování do proměnných}
\label{valuereference_a_prirazovani_do_promennych}

Proměnné jsou ve skriptu reprezentovány třídou \texttt{ValueIdentifier}, která v sobě u\-cho\-vá\-vá identifikátor hodnoty odkazující do kontextu skriptu. Všechny operace se vykonávají stejně jako u ostatních tříd, rozdíl spočívá pouze v tom, že se neprovádějí přímo s daným objektem, ale s odkazovaným.

Jelikož je navržený jazyk beztypový, proměnné musejí umět měnit nejen svou hodnotu, ale i datový typ, jedná se tedy o složitější operaci, než je pouhá záměna jednoho čísla za jiné. Interpret tuto situaci řeší obalením vlastní hodnoty další třídou pojmenovanou \texttt{ValueReference}, přiřazení poté probíhá podle následujícího schématu.

\begin{enumerate}
\item Operátor přiřazení vyhodnotí výraz na své levé straně
	\begin{itemize}
	\item Proměnná požádá kontext o nalezení hodnoty uložené pod daným jménem
	\item Pole poskytne prvek na daném indexu
	\item Struktura najde prvek specifikovaného jména
	\item Kombinace předchozích
	\end{itemize}
\item Výsledkem je vždy hodnota obalená ve třídě \texttt{ValueReference}
\item Operátor přiřazení vyhodnotí výraz na své pravé straně
\item \texttt{ValueReference} je požádáno o záměnu obalené hodnoty za novou
\end{enumerate}

V případě, že proměnná daného jména, popř. položka struktury, ještě neexistuje, nově vytvořená \texttt{ValueReference} obaluje \texttt{ValueNull} hodnotu. Pole se při přístupu za své hranice automaticky nezvětšuje, je vypsána chyba.


\subsubsection{Grafové třídy}

TODO: nejspíš budou ještě nějaké změny


\subsection{Abstraktní strom syntaxe, Node* hierarchie tříd}

Abstraktní třída \texttt{Node} byla již představena v analýze, v kapitole \ref{abstraktni_strom_syntaxe} na straně \pageref{abstraktni_strom_syntaxe}. Z ní vycházázejí všechny ostatní třídy, jejichž objekty budou tvořit abstraktní strom syntaxe skriptu.

Unární operátory jsou potomky třídy \texttt{NodeUnary}, která předpokládá jeden poduzel ve stromě, \texttt{NodeBinary} logicky dva. Ternální operátor je interně mapován na \texttt{if-else} větvení poskytované třídou \texttt{NodeCondition}. Dalšími podtřídami jsou například \texttt{Node\-Loop} a \texttt{NodeForeach} cykly, \texttt{NodeBlock} zapouzdřující skupinu příkazů, \texttt{Node\-Function\-Call} pro volání funkcí, či prázdný příkaz \texttt{NodeEmptyCommand} využívaný spíše interně.


\subsubsection{Strukturované skoky}

Strukturované skoky \texttt{break}, \texttt{continue} a \texttt{return} používají mechanismus výjimek, což je jedna z mála výraznějších daní za jednoduchost vykonávání skriptu pomocí rekurzivního volání metody \texttt{execute()}. Příkaz skoku, byť strukturovaný, musí být nějakým způsobem schopen opustit zanořené volání a vystoupat do požadovaného místa. Výjimky jsou zde opravdu tou nejelegantnější cestou k naprogramování této funkcionality.

Vlastní skok spočívá v jediném řádku obsahujícím \texttt{throw}, například pro \texttt{break} vypadá kód následovně.

\begin{verbatim}
CountPtr<Value> NodeJumpBreak::execute(void)
{
    throw this;
}
\end{verbatim}

Místo, kde se má skok zastavit je definováno strukturou objektů ve stromu. Například výše uvedený příkaz \texttt{break} by se měl zastavit za koncem nejzanořenějšího cyklu. V případě \texttt{continue} se samozřejmě jedná o návrat na začátek před další iteraci. Přesně podle této definice funguje \texttt{NodeLoop} uzel, výjimka typu \texttt{NodeJumpBreak} je zachytávána za tělem cyklu, \texttt{NodeJumpContinue} uvnitř.

\begin{verbatim}
CountPtr<Value> NodeLoop::execute(void)
{
    m_init->execute();

    try
    {
        while(m_condition->execute()->toBool())
        {
            try
            {
                m_body->execute();
            }
            catch(NodeJumpContinue* ex) { }

            m_inc->execute();
        }
    }
    catch(NodeJumpBreak* ex) { }
}
\end{verbatim}

Protože volání cyklů probíhá od vnějších k vnitřním, je případná výjimka vždy zachycena v nejvnitřnějším cyklu. Výkonostní poměry u těchto typů konstrukcí příliš neutrpí, \texttt{break} a \texttt{continue} se v reálných programech vyskytují spíše zřídka.

U návratových hodnot je situace opačná, \texttt{return} se vyskytuje téměř v každé z funkcí. Ano, zde jsou výjimky bolestné, ale z druhé strany pohledu ne tak moc jako implementace bez jejich služeb.

Bylo by možné, aby příkaz \texttt{return} nastavil hodnotu nějaké sdílené proměnné v kontextu na výstupní hodnotu z funkce a zároveň v další proměnné signalizoval, že probíhá návrat z funkce. Metoda \texttt{execute()} by u naprosto všech tříd musela testovat tuto signalizační proměnnou, a v době mezi \texttt{return} až do ukončení těla by se nezanořovala do dalších příkazů. Obrovské množství těchto větvení by jiště přesáhlo režii jedné nastanuvší výjimky.


\subsubsection{Funkce}

Funkce, potomci třídy \texttt{NodeFunction} se dělí na dvě skupiny -- na zapsané ve skriptu a na zabudované do interpretu. Každou z nich identifikuje jméno a parametry, při volání se ovšem používá pouze jméno. První typ funkcí také očekává tělo s příkazy a pozici ve zdrojových kódech, kde je definována. U zabudovaných funkcí, potomků \texttt{Node\-Function\-Builtin}, tyto informace nemají význam, tělo je specifikováno přímo C++ kódem metody \texttt{execute()}.

Všechny definované, a tudíž i volatelné, funkce ukládá kontext skriptu. Není třeba, aby věděl, o který z obou typů se jedná, samotné objekty to ví a díky polymorfismu se budou volat správné metody.

\begin{verbatim}
map<identifier, NodeFunction*> m_functions;
\end{verbatim}

Kód funkce umí zavolat třída \texttt{NodeFunctionCall}. Ta se ji nejdříve pokusí pomocí uloženého jména najít a zkontroluje počty deklarovaných a předaných parametrů. Pokud vše souhlasí, vyhodnotí parametry, vloží na zásobník volání novou položku, podle specifikovaných jmen parametrů definuje požadované proměnné a spustí tělo funkce.


\subsection{Generátory zdrojových kódů}

Interpret obsahuje několik skupin tříd, jejichž kód je velice podobný, typickým příkladem jsou třídy aritmetických a logických operátorů. Vezměme si třeba operátory pro sčítání a odčítání, jejich výkonná část se liší jediným příkazem. Sčítání volá metodu \texttt{add()} a odčítání logicky \texttt{sub()}, jinak je celý kód identický.

\begin{verbatim}
    return m_left->execute()->add(*(m_right->execute()));
    return m_left->execute()->sub(*(m_right->execute()));
\end{verbatim}

Kromě těchto dvou je potřeba dalších dvacet binárních operátorů, k tomu několik unárních operátorů a nesmí se zapomenout ani na zabudované funkce. Vytvářet všechny třídy ručně je zdlouhavé a neefektivní, v případě změn je třeba upravovat stejným způsobem mnoho souborů.

Nepříliš vhodné řešení této situace je využítí C++ maker, jimiž lze generovat i kód tříd. Jedna z primitivnějších, ne moc hezkých, implementací by mohla vypadat například následovně.

\begin{verbatim}
#define UNARYOPERATOR(NAME, CODE)             \
class NAME : public NodeBinary                \
{                                             \
public:                                       \
    NAME(Node* next) : NodeUnary(next) { }    \
                                              \
    virtual CountPtr<Value> execute(void)     \
    {                                         \
        CODE                                  \
    }                                         \
};
\end{verbatim}

Jedná se o plně funkční kód v profesionální praxi běžně používaný, ale obecně špatně na\-vr\-že\-ný. Kvůli těmto konstrukcím není možný debugging a také nefunguje automatické do\-pl\-ňo\-vá\-ní, protože s podobným zápisem tvůrci žádného IDE zkrátka nepočítali. Počáteční úsporu a zrychlení velice rychle, při prvních problémech a neúspěšných pokusech o ladění, vystřídají myšlenky na kompletní přepsání.

Řešením situace je sáhnout po externím skriptu, jehož jediným posláním bude podle při\-pra\-ve\-né šablony generovat C++ soubory s definicí jednotlivých tříd. Pokud vznikne požadavek na úpravu, změní se šablona a skript všechny soubory během krátké chvíle automaticky přegeneruje.

V aplikaci toto navržené řešení používají jednoduché perlovské skripty \texttt{gen\_operators.pl} a \texttt{gen\_builtin.pl}, které generují C++ kód unárních i binárních operátorů a také zabudovaných funkcí.


\subsection{Lexikální analyzátor}

Jako základ pro lexikální analyzátor byl použit zdrojový kód z předchozího autorova projektu \cite[třída \texttt{CLexan}]{borsch}. Jeho jádrem je rozsáhlý stavový automat, který zpracovává příchozí znaky a v závislosti na nich vrací lexikální tokeny.

Analyzátor bere v úvahu konstanty \texttt{\_\_FILE\_\_}, \texttt{\_\_LINE\_\_} a \texttt{\_\_FUNCTION\_\_}, které se při svém použití automaticky nahrazují za pozice ve zdrojových kódech. Dalšími vnitřními příkazy jsou definování jednoduchých bezparametrických maker a vkládání externích souborů.

\begin{verbatim}
define("name", "value");
include("filename");
\end{verbatim}


\subsubsection{Procházení zdrojových dat}

Makra i inkludované soubory se ve svém principu zpracovávají naprosto stejně. Lexikální analyzátor obsahuje zásobník objektů typu \texttt{LexanIterator}, který slouží pro zanoření se do další úrovně ve zdrojových kódech. Například při inkludování souboru se na vrcholu zásobníku vytvoří nová položka, při dokončení jeho zpracování se naopak odstraní. Překlad končí ve chvíli, kdy je zásobník vyprázdněn.

Abstraktní třída \texttt{LexanIterator} definuje rozhraní pro nejnižší vrstvu -- vlastní čtení znaků. Jediný požadavek na potomky je specifikace metody \texttt{get()}, která má za úkol vrátit následující znak v pořadí a \texttt{unget()} sloužící pro návrat o znak zpátky. Třída dále ukládá pozici ve zdrojových kódech používanou především ve zprávách v případě chyby.

Aktuálně jsou definováni pouze dva potomci. \texttt{LexanIteratorFile} má za úkol iterovat přes znaky v souboru, používá ho konstrukce \texttt{include} a \texttt{Le\-xan\-Ite\-ra\-tor\-String} zpracovává ře\-těz\-ce, slouží pro rozbalování \texttt{define} maker. V budoucnu je možné, bez větších zásahů do aplikace, přidat další zdroje, například soubory nahrávané z internetu.


\subsubsection{Identifikátory}

Řetězcové identifikátory, jména proměnných a funkcí, jsou během lexikální analýzy nahrazovány za celočíselné, stejnou myšlenku používá i interpret JavaScriptu ve webovém prohlížeči Links \cite[str. 25]{links}.

Ve chvíli, kdy lexikální analyzátor narazí ve zdrojovém proudu na shluk znaků, který by mohl být identifikátorem, zkontroluje nejdříve, zda se nejedná o klíčové slovo. V případě negativního výsledku projde seznam skriptem definovaných maker a pokusí se je rozbalit. Neuspěje-li ani zde, použije makro \texttt{STR2ID(string)}, které požádá tabulku symbolů, třídu \texttt{StringTable}, o překlad řetězce na celočíselný identifikátor. Opačný směr umožňuje makro \texttt{ID2STR(identifier)}.

Algoritmus překladu je velice jednoduchý. Tabulka symbolů obsahuje obyčejné pole, jehož jednotlivé položky ukládají řetězcovou reprezentaci, hodnota indexu představuje reprezentaci číselnou. Při žádosti o překlad z řetězce na identifikátor, zkusí třída najít a vrátit pozici již existujícího prvku. Pokud neuspěje, přidá řetězec na konec pole a vrátí jeho pozici. Složitost operace vychází v nejhorším případě lineární, musí se projít všechny prvky. Opačný směr představuje operaci s konstatní složitostí, identifikátor je současně indexem do pole.

\begin{verbatim}
identifier StringTable::getID(const string& str)
{
    vector<string>::iterator pos = find(m_data.begin(), m_data.end(), str);

    if(pos == m_data.end())
        m_data.push_back(str);

    return pos - m_data.begin();
}

string& StringTable::getString(identifier id)
{
    assert(id < m_data.size());
    return m_data[id];
}
\end{verbatim}

Hlavní výhodou této techniky je vyšší rychlost interpretace, porovnání dvou čísel trvá mnohem kratší dobu než porovnání dvou řetězců. Úspora vzniká při každém přístupu k hodnotě proměnné a při volání funkcí. Druhá z výhod spočívá ve snížených paměťových nárocích, všechny řetězce jsou uloženy na jednom místě a ve skriptu je reprezentují pouze celočíselné hodnoty. Jak už bylo zmíněno, jediné zpomalení nastává při vytváření tabulky symbolů, je přímo úměrné počtu různých identifikátorů ve zdrojovém textu.


\subsection{Gramatika, Bison}



\subsection{Shrnutí}



\section{Grafické uživatelské rozhraní}

\subsection{Hlavní okno}

\subsection{Editor}

Code Editor Example
http://doc.trolltech.com/4.5/widgets-codeeditor.html

\subsection{Debugger}


\subsubsection{Vykonávání kódu}

Recursive traversion of AST, mutexes


\subsubsection{Zabudovaná funkce breakpoint()}

\subsubsection{Proměnné skriptu}

\subsubsection{Zásobník volání funkcí}


\subsection{Vizualizace grafu}

\subsection{Shrnutí}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Testování}

% TODO: delete
\begin{itemize}
 \item Způsob, průběh a výsledky testování.
 \item Srovnání s existujícími řešeními, pokud jsou známy.
\end{itemize}

\section{Unit testy}

\section{Skriptové unit testy}

\section{Benchmarks}

\section{Použitelnost}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Závěr}

% TODO: delete
\begin{itemize}
\item Zhodnocení splnění cílů DP/BP a  vlastního přínosu práce (při formulaci je třeba vzít v potaz zadání práce).
\item Diskuse dalšího možného pokračování práce.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

% http://www.fit.vutbr.cz/~martinek/latex/czechiso.html.cs.iso-8859-2
% http://cs.wikipedia.org/wiki/BibTeX

\bibliographystyle{czechiso}
{
\def\CS{$\cal C\kern-0.1667em\lower.5ex\hbox{$\cal S$}\kern-0.075em $}
\bibliography{reference}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\appendix


\chapter{Gramatika jazyka}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Hierarchie tříd}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Vývojové prostředí}

\section{Vývojové nástroje, verze}
\section{Kompilování}
\section{Spuštění, parametry příkazové řádky}
\section{Grafické uživatelské rozhraní}

base code for the application qt4/examples/mainwindows/mdi


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Seznam použitých zkratek}
\begin{description}
\setlength{\labelwidth}{2.5cm}
\setlength{\itemindent}{1.5cm}
\item[LALR] Look Ahead Left to Right (grammar type)
\item[STL] Standard Template Library
\item[AST] Abstract Syntax Tree
\item[CLI] Command Line Interface
\item[GUI] Graphics User Interface
\item[OOP] Object Oriented Programming
\item[I/O] Input/Output
\item[OpenGL] Open Graphics Library
\item[MDI] Multiple Document Interface
\item[XML] eXtensible Markup Language
\item[RTTI] Run-Time Type Information
\end{description}
\vdots


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{UML diagramy}

TODO: X36ASS


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Instalační a uživatelská příručka}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%

\chapter{Obsah přiloženého CD}


\end{document}
